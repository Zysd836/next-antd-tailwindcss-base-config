import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'

export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
  /** Represents untyped JSON */
  JSON: any;
};

/** Autogenerated input type of AcceptFaqAnswerMutation */
export type AcceptFaqAnswerMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of AcceptFaqAnswerMutation */
export type AcceptFaqAnswerMutationPayload = {
  __typename?: 'AcceptFaqAnswerMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  faqAnswer: FaqAnswer;
};

export enum AcceptedTypeEnum {
  Archive = 'ARCHIVE',
  Audio = 'AUDIO',
  Document = 'DOCUMENT',
  Image = 'IMAGE',
  TestCase = 'TEST_CASE',
  Video = 'VIDEO'
}

export type ActiveRecordInterface = {
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type Authorization = {
  __typename?: 'Authorization';
  accessToken: Scalars['String'];
  user: User;
};

export type CalculateJobQuizPointInput = {
  optionIds: Array<Scalars['ID']>;
};

/** Autogenerated input type of CalculateJobQuizPointMutation */
export type CalculateJobQuizPointMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CalculateJobQuizPointInput;
};

/** Autogenerated return type of CalculateJobQuizPointMutation */
export type CalculateJobQuizPointMutationPayload = {
  __typename?: 'CalculateJobQuizPointMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  result: Scalars['JSON'];
};

export type CategoriesSearchResult = {
  __typename?: 'CategoriesSearchResult';
  node: Array<Category>;
  pageInfo: Result;
};

export type Category = ActiveRecordInterface & {
  __typename?: 'Category';
  ancestors?: Maybe<Array<Category>>;
  ancestry?: Maybe<Scalars['String']>;
  children?: Maybe<Array<Category>>;
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  parent?: Maybe<Category>;
  slug?: Maybe<Scalars['String']>;
  thumbnail?: Maybe<PublicFile>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type CategoryInput = {
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  parentId?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
  thumbnailId?: InputMaybe<Scalars['ID']>;
};

export type ChangePasswordInput = {
  newPassword: Scalars['String'];
  oldPassword: Scalars['String'];
};

/** Autogenerated input type of ChangePasswordMutation */
export type ChangePasswordMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: ChangePasswordInput;
};

/** Autogenerated return type of ChangePasswordMutation */
export type ChangePasswordMutationPayload = {
  __typename?: 'ChangePasswordMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  user: User;
};

export type CodeSuggestion = ActiveRecordInterface & {
  __typename?: 'CodeSuggestion';
  content: Scalars['String'];
  /** Phần trăm điểm bị trừ */
  cost: Scalars['Int'];
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  language?: Maybe<Language>;
  languageId?: Maybe<Scalars['Int']>;
  topicSectionId: Scalars['Int'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type CodeSuggestionRequest = ActiveRecordInterface & {
  __typename?: 'CodeSuggestionRequest';
  codeSuggestionId: Scalars['ID'];
  /** Nội dung gợi ý */
  content: Scalars['String'];
  /** Phần trăm điểm bị trừ */
  cost: Scalars['Int'];
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type CodeSuggestionRequestInput = {
  codeSuggestionId: Scalars['ID'];
};

export type CodingExam = SectionItemInterface & {
  __typename?: 'CodingExam';
  createdAt: Scalars['ISO8601DateTime'];
  /** Mô tả */
  description?: Maybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: Maybe<DifficultyEnum>;
  id: Scalars['ID'];
  /** Đã hoàn thành */
  isCompleted: Scalars['Boolean'];
  limit: CodingExamLimit;
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  owner?: Maybe<User>;
  slug?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  testCases: Array<CodingExamTestCase>;
  testCasesFile: PublicFile;
  title: Scalars['String'];
  topicSection?: Maybe<TopicSection>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type CodingExamTopicSectionArgs = {
  programId: Scalars['ID'];
};

export type CodingExamLimit = {
  __typename?: 'CodingExamLimit';
  memoryLimit?: Maybe<Scalars['Int']>;
  sourceLimit?: Maybe<Scalars['Int']>;
  timeLimit?: Maybe<Scalars['Int']>;
};

export type CodingExamLimitInput = {
  memoryLimit?: InputMaybe<Scalars['Int']>;
  sourceLimit?: InputMaybe<Scalars['Int']>;
  timeLimit?: InputMaybe<Scalars['Int']>;
};

export type CodingExamSubmission = ExamSubmissionInterface & {
  __typename?: 'CodingExamSubmission';
  caseResults?: Maybe<Scalars['JSON']>;
  correctRatio?: Maybe<Scalars['Float']>;
  createdAt: Scalars['ISO8601DateTime'];
  error?: Maybe<CodingExamSubmissionError>;
  id: Scalars['ID'];
  isJudged: Scalars['Boolean'];
  language: Language;
  owner: User;
  src: Scalars['String'];
  stat?: Maybe<ExamSubmissionStat>;
  totalPoints?: Maybe<Scalars['Float']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type CodingExamSubmissionError = {
  __typename?: 'CodingExamSubmissionError';
  message?: Maybe<Scalars['String']>;
  type?: Maybe<SubmissionErrorTypeEnum>;
};

export type CodingExamSubmissionInput = {
  codingExamId: Scalars['ID'];
  languageId: Scalars['ID'];
  programId: Scalars['ID'];
  src: Scalars['String'];
};

export type CodingExamTestCase = {
  __typename?: 'CodingExamTestCase';
  input: Scalars['String'];
  output: Scalars['String'];
};

export type CodingExamsSearchResult = {
  __typename?: 'CodingExamsSearchResult';
  node: Array<CodingExam>;
  pageInfo: Result;
};

export type Comment = ActiveRecordInterface & {
  __typename?: 'Comment';
  children: Array<Comment>;
  content?: Maybe<Scalars['String']>;
  contentHtml?: Maybe<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  ownedVote?: Maybe<Vote>;
  updatedAt: Scalars['ISO8601DateTime'];
  user: User;
  votes: Array<Vote>;
  votesSum?: Maybe<Scalars['Int']>;
};

export enum CommentableTypeEnum {
  Post = 'POST',
  Program = 'PROGRAM'
}

/** Autogenerated input type of ConfirmEmailMutation */
export type ConfirmEmailMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  token: Scalars['String'];
};

/** Autogenerated return type of ConfirmEmailMutation */
export type ConfirmEmailMutationPayload = {
  __typename?: 'ConfirmEmailMutationPayload';
  accessToken?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  /** :ok or :error */
  status?: Maybe<Scalars['String']>;
};

export type Course = ActiveRecordInterface & {
  __typename?: 'Course';
  categories: Array<Category>;
  comments: Array<Comment>;
  cover?: Maybe<PublicFile>;
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  difficulty?: Maybe<DifficultyEnum>;
  duration?: Maybe<Scalars['Int']>;
  examsCount: Scalars['Int'];
  haveCertificate: Scalars['Boolean'];
  id: Scalars['ID'];
  isDraft?: Maybe<Scalars['Boolean']>;
  isFavorite?: Maybe<Scalars['Boolean']>;
  isFeatured?: Maybe<Scalars['Boolean']>;
  /** Check xem user hiện tại đã join vào program này chưa */
  isJoined?: Maybe<Scalars['Boolean']>;
  isTrending?: Maybe<Scalars['Boolean']>;
  languages: Array<Language>;
  lessonsCount?: Maybe<Scalars['Int']>;
  meta?: Maybe<Scalars['JSON']>;
  /** Phần trăm tiến độ */
  ownedProgress?: Maybe<Scalars['Float']>;
  owner: User;
  programsUsersCount: Scalars['Int'];
  readingTopicSection?: Maybe<TopicSection>;
  slug?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  title?: Maybe<Scalars['String']>;
  topics?: Maybe<Array<Topic>>;
  totalPoints: Scalars['Int'];
  updatedAt: Scalars['ISO8601DateTime'];
  viewsCount: Scalars['Int'];
};

export type CourseCertificatesSearchResult = {
  __typename?: 'CourseCertificatesSearchResult';
  node: Array<UserCertificate>;
  pageInfo: Result;
};

export type CourseLesson = SectionItemInterface & {
  __typename?: 'CourseLesson';
  content: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  /** Độ khó */
  difficulty?: Maybe<DifficultyEnum>;
  duration?: Maybe<Scalars['Int']>;
  featureImage?: Maybe<PublicFile>;
  id: Scalars['ID'];
  isDraft?: Maybe<Scalars['Boolean']>;
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  owner?: Maybe<User>;
  slug?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  title: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
  video?: Maybe<PublicFile>;
};

export type CourseLessonInput = {
  content: Scalars['String'];
  /** Thời lượng bài học (phút) */
  duration?: InputMaybe<Scalars['Int']>;
  featureImageId?: InputMaybe<Scalars['ID']>;
  isDraft?: InputMaybe<Scalars['Boolean']>;
  slug?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
  videoId?: InputMaybe<Scalars['ID']>;
};

export type CourseLessonsSearchResult = {
  __typename?: 'CourseLessonsSearchResult';
  node: Array<CourseLesson>;
  pageInfo: Result;
};

export type CoursesSearchResult = {
  __typename?: 'CoursesSearchResult';
  node: Array<Course>;
  pageInfo: Result;
};

export type CreateAttachmentInput = {
  /** Id of uploaded file */
  id: Scalars['String'];
  /** Metadata */
  metadata: Scalars['JSON'];
  /** Storage: cache or store */
  storage: StorageTypeEnum;
};

/** Autogenerated input type of CreateCategoryMutation */
export type CreateCategoryMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CategoryInput;
};

/** Autogenerated return type of CreateCategoryMutation */
export type CreateCategoryMutationPayload = {
  __typename?: 'CreateCategoryMutationPayload';
  category: Category;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

export type CreateCodeSuggestionInput = {
  content: Scalars['String'];
  /** Phần trăm điểm bị trừ */
  cost: Scalars['Int'];
  languageId?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of CreateCodeSuggestionRequestMutation */
export type CreateCodeSuggestionRequestMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CodeSuggestionRequestInput;
};

/** Autogenerated return type of CreateCodeSuggestionRequestMutation */
export type CreateCodeSuggestionRequestMutationPayload = {
  __typename?: 'CreateCodeSuggestionRequestMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  codeSuggestionRequest: CodeSuggestionRequest;
};

export type CreateCodingExamInput = {
  /** Mô tả */
  description?: InputMaybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: InputMaybe<DifficultyEnum>;
  limit?: InputMaybe<CodingExamLimitInput>;
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Id của file test case (PublicFile id) */
  testCasesFileId: Scalars['ID'];
  title: Scalars['String'];
};

/** Autogenerated input type of CreateCodingExamMutation */
export type CreateCodingExamMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateCodingExamInput;
};

/** Autogenerated return type of CreateCodingExamMutation */
export type CreateCodingExamMutationPayload = {
  __typename?: 'CreateCodingExamMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  codingExam: CodingExam;
};

/** Autogenerated input type of CreateCodingExamSubmissionMutation */
export type CreateCodingExamSubmissionMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CodingExamSubmissionInput;
};

/** Autogenerated return type of CreateCodingExamSubmissionMutation */
export type CreateCodingExamSubmissionMutationPayload = {
  __typename?: 'CreateCodingExamSubmissionMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  codingExamSubmission: CodingExamSubmission;
};

export type CreateCommentInput = {
  commentableId: Scalars['ID'];
  commentableType: CommentableTypeEnum;
  content: Scalars['String'];
  contentHtml: Scalars['String'];
  parentId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated input type of CreateCommentMutation */
export type CreateCommentMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateCommentInput;
};

/** Autogenerated return type of CreateCommentMutation */
export type CreateCommentMutationPayload = {
  __typename?: 'CreateCommentMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  comment: Comment;
};

export type CreateCourseInput = {
  categoryIds: Array<Scalars['ID']>;
  /** Ảnh khóa học */
  coverId?: InputMaybe<Scalars['ID']>;
  /** Mô tả khóa học */
  description: Scalars['String'];
  /** Độ khó của khóa học */
  difficulty?: InputMaybe<DifficultyEnum>;
  /** Thời lượng khóa học (giờ) */
  duration?: InputMaybe<Scalars['Int']>;
  haveCertificate?: InputMaybe<Scalars['Boolean']>;
  isDraft?: InputMaybe<Scalars['Boolean']>;
  /** Đánh dấu khóa học nổi bật */
  isFeatured?: InputMaybe<Scalars['Boolean']>;
  /** Đánh dấu khóa học thịnh hành */
  isTrending?: InputMaybe<Scalars['Boolean']>;
  /** Ngôn ngữ */
  languageIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Meta */
  meta?: InputMaybe<Scalars['JSON']>;
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Tiêu đề khóa học */
  title: Scalars['String'];
  /** Topics của khóa học */
  topicsAttributes?: InputMaybe<Array<CreateTopicInput>>;
};

/** Autogenerated input type of CreateCourseLessonMutation */
export type CreateCourseLessonMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CourseLessonInput;
};

/** Autogenerated return type of CreateCourseLessonMutation */
export type CreateCourseLessonMutationPayload = {
  __typename?: 'CreateCourseLessonMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  courseLesson: CourseLesson;
};

/** Autogenerated input type of CreateCourseMutation */
export type CreateCourseMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateCourseInput;
};

/** Autogenerated return type of CreateCourseMutation */
export type CreateCourseMutationPayload = {
  __typename?: 'CreateCourseMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  course: Course;
};

/** Autogenerated input type of CreateDirectoryMutation */
export type CreateDirectoryMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: DirectoryInput;
};

/** Autogenerated return type of CreateDirectoryMutation */
export type CreateDirectoryMutationPayload = {
  __typename?: 'CreateDirectoryMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  directory: Directory;
};

/** Autogenerated input type of CreateEducationMutation */
export type CreateEducationMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: EducationInput;
};

/** Autogenerated return type of CreateEducationMutation */
export type CreateEducationMutationPayload = {
  __typename?: 'CreateEducationMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  education: Education;
};

/** Autogenerated input type of CreateFaqAnswerMutation */
export type CreateFaqAnswerMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: FaqAnswerInput;
};

/** Autogenerated return type of CreateFaqAnswerMutation */
export type CreateFaqAnswerMutationPayload = {
  __typename?: 'CreateFaqAnswerMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  faqAnswer: FaqAnswer;
};

/** Autogenerated input type of CreateFaqMutation */
export type CreateFaqMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: FaqInput;
};

/** Autogenerated return type of CreateFaqMutation */
export type CreateFaqMutationPayload = {
  __typename?: 'CreateFaqMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  faq: Faq;
};

/** Autogenerated input type of CreateFavoriteCourseMutation */
export type CreateFavoriteCourseMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: FavoriteCourseInput;
};

/** Autogenerated return type of CreateFavoriteCourseMutation */
export type CreateFavoriteCourseMutationPayload = {
  __typename?: 'CreateFavoriteCourseMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  favoriteCourse: FavoriteCourse;
};

export type CreateGapFillExamInput = {
  content: Scalars['String'];
  /** Mô tả */
  description?: InputMaybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: InputMaybe<DifficultyEnum>;
  gapValues: Array<Scalars['String']>;
  isIgnoreCase?: InputMaybe<Scalars['Boolean']>;
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  title: Scalars['String'];
};

/** Autogenerated input type of CreateGapFillExamMutation */
export type CreateGapFillExamMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateGapFillExamInput;
};

/** Autogenerated return type of CreateGapFillExamMutation */
export type CreateGapFillExamMutationPayload = {
  __typename?: 'CreateGapFillExamMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  gapFillExam: GapFillExam;
};

/** Autogenerated input type of CreateGapFillExamSubmissionMutation */
export type CreateGapFillExamSubmissionMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: GapFillExamSubmissionInput;
};

/** Autogenerated return type of CreateGapFillExamSubmissionMutation */
export type CreateGapFillExamSubmissionMutationPayload = {
  __typename?: 'CreateGapFillExamSubmissionMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  gapFillExamSubmission: GapFillExamSubmission;
};

export type CreateJobQuizOptionInput = {
  /** Content */
  content: Scalars['String'];
  personalityIds: Array<Scalars['ID']>;
  rowOrderPosition: Scalars['Int'];
};

export type CreateLearningPathInput = {
  /** Lợi ích sau khi học khóa học */
  benefits: Scalars['JSON'];
  /** Học đầy đủ khóa học mang lại */
  benefitsSummary: Scalars['JSON'];
  /** Ảnh */
  coverId?: InputMaybe<Scalars['ID']>;
  /** Mô tả */
  description: Scalars['String'];
  /** Độ khó của khóa học */
  difficulty?: InputMaybe<DifficultyEnum>;
  /** Thời lượng */
  duration: Scalars['Int'];
  /** Khóa học bao gồm */
  includes: Scalars['String'];
  learningPathsProgramsAttributes: Array<CreateLearningPathsProgramInput>;
  /** Meta */
  meta?: InputMaybe<Scalars['JSON']>;
  /** Các dự án bạn sẽ xây dựng */
  projects: Scalars['JSON'];
  slug?: InputMaybe<Scalars['String']>;
  /** Tổng quan */
  summary: Scalars['String'];
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Khóa học dành cho  */
  target: Scalars['String'];
  /** Tiêu đề */
  title: Scalars['String'];
};

/** Autogenerated input type of CreateLearningPathMutation */
export type CreateLearningPathMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateLearningPathInput;
};

/** Autogenerated return type of CreateLearningPathMutation */
export type CreateLearningPathMutationPayload = {
  __typename?: 'CreateLearningPathMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  learningPath: LearningPath;
};

export type CreateLearningPathsProgramInput = {
  programId: Scalars['ID'];
  rowOrderPosition: Scalars['Int'];
};

export type CreateOrganizedExamInput = {
  allowList: Array<Scalars['String']>;
  canRunCode?: InputMaybe<Scalars['Boolean']>;
  content: Scalars['String'];
  denyList: Array<Scalars['String']>;
  /** Mô tả */
  description?: InputMaybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: InputMaybe<DifficultyEnum>;
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  title: Scalars['String'];
};

/** Autogenerated input type of CreateOrganizedExamMutation */
export type CreateOrganizedExamMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateOrganizedExamInput;
};

/** Autogenerated return type of CreateOrganizedExamMutation */
export type CreateOrganizedExamMutationPayload = {
  __typename?: 'CreateOrganizedExamMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  organizedExam: OrganizedExam;
};

/** Autogenerated input type of CreateOrganizedExamSubmissionMutation */
export type CreateOrganizedExamSubmissionMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: OrganizedExamSubmissionInput;
};

/** Autogenerated return type of CreateOrganizedExamSubmissionMutation */
export type CreateOrganizedExamSubmissionMutationPayload = {
  __typename?: 'CreateOrganizedExamSubmissionMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  organizedExamSubmission: OrganizedExamSubmission;
};

export type CreatePostInput = {
  categoryIds: Array<Scalars['ID']>;
  /** Nội dung bài viết */
  content: Scalars['String'];
  /** Meta */
  meta?: InputMaybe<Scalars['JSON']>;
  /** bài viết liên quan */
  relatedBridgesAttributes?: InputMaybe<Array<CreateRelatedBridgeInput>>;
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Ảnh xem trước của bài viết */
  thumbnailId?: InputMaybe<Scalars['ID']>;
  /** Tiêu đề bài viết */
  title: Scalars['String'];
};

/** Autogenerated input type of CreatePostMutation */
export type CreatePostMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreatePostInput;
};

/** Autogenerated return type of CreatePostMutation */
export type CreatePostMutationPayload = {
  __typename?: 'CreatePostMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  post: Post;
};

export type CreatePracticeInput = {
  categoryIds: Array<Scalars['ID']>;
  /** Ảnh khóa học */
  coverId?: InputMaybe<Scalars['ID']>;
  /** Mô tả khóa học */
  description: Scalars['String'];
  /** Độ khó của khóa học */
  difficulty?: InputMaybe<DifficultyEnum>;
  /** Thời lượng khóa học (giờ) */
  duration?: InputMaybe<Scalars['Int']>;
  haveCertificate?: InputMaybe<Scalars['Boolean']>;
  isDraft?: InputMaybe<Scalars['Boolean']>;
  /** Đánh dấu khóa học nổi bật */
  isFeatured?: InputMaybe<Scalars['Boolean']>;
  /** Đánh dấu khóa học thịnh hành */
  isTrending?: InputMaybe<Scalars['Boolean']>;
  /** Ngôn ngữ */
  languageIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Meta */
  meta?: InputMaybe<Scalars['JSON']>;
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Tiêu đề khóa học */
  title: Scalars['String'];
  /** Topics của khóa học */
  topicsAttributes?: InputMaybe<Array<CreateTopicInput>>;
};

/** Autogenerated input type of CreatePracticeMutation */
export type CreatePracticeMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreatePracticeInput;
};

/** Autogenerated return type of CreatePracticeMutation */
export type CreatePracticeMutationPayload = {
  __typename?: 'CreatePracticeMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  practice: Practice;
};

export type CreatePublicFileInput = {
  /** Attachment */
  attachment: CreateAttachmentInput;
  /** Directory Id */
  directoryId: Scalars['ID'];
};

/** Autogenerated input type of CreatePublicFileMutation */
export type CreatePublicFileMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreatePublicFileInput;
};

/** Autogenerated return type of CreatePublicFileMutation */
export type CreatePublicFileMutationPayload = {
  __typename?: 'CreatePublicFileMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  publicFile: PublicFile;
};

export type CreateQuizExamInput = {
  /** Mô tả */
  description?: InputMaybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: InputMaybe<DifficultyEnum>;
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  quizQuestBridgesAttributes?: InputMaybe<Array<CreateQuizQuestBridgeInput>>;
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  title: Scalars['String'];
};

/** Autogenerated input type of CreateQuizExamMutation */
export type CreateQuizExamMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateQuizExamInput;
};

/** Autogenerated return type of CreateQuizExamMutation */
export type CreateQuizExamMutationPayload = {
  __typename?: 'CreateQuizExamMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  quizExam: QuizExam;
};

/** Autogenerated input type of CreateQuizExamSubmissionMutation */
export type CreateQuizExamSubmissionMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: QuizExamSubmissionInput;
};

/** Autogenerated return type of CreateQuizExamSubmissionMutation */
export type CreateQuizExamSubmissionMutationPayload = {
  __typename?: 'CreateQuizExamSubmissionMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  quizExamSubmission: QuizExamSubmission;
};

export type CreateQuizQuestBridgeInput = {
  quizQuestId: Scalars['ID'];
  rowOrderPosition: Scalars['Int'];
};

/** Autogenerated input type of CreateQuizQuestMutation */
export type CreateQuizQuestMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: QuizQuestInput;
};

/** Autogenerated return type of CreateQuizQuestMutation */
export type CreateQuizQuestMutationPayload = {
  __typename?: 'CreateQuizQuestMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  quizQuest: QuizQuest;
};

export type CreateRelatedBridgeInput = {
  rowOrderPosition: Scalars['Int'];
  toId: Scalars['ID'];
  toType: RelatedBridgeTypeEnum;
};

export type CreateSampleCodeInput = {
  code: Scalars['String'];
  languageId: Scalars['Int'];
};

export type CreateTopicInput = {
  isDraft?: InputMaybe<Scalars['Boolean']>;
  /** Tên topic */
  name: Scalars['String'];
  /** Thứ tự của topic */
  rowOrderPosition: Scalars['Int'];
  /** Tổng quan topic */
  summary?: InputMaybe<Scalars['String']>;
  /** Danh sách section của topics */
  topicSectionsAttributes?: InputMaybe<Array<CreateTopicSectionInput>>;
};

export type CreateTopicSectionInput = {
  codeSuggestionsAttributes?: InputMaybe<Array<CreateCodeSuggestionInput>>;
  rowOrderPosition: Scalars['Int'];
  sampleCodesAttributes?: InputMaybe<Array<CreateSampleCodeInput>>;
  sectionItemId: Scalars['ID'];
};

/** Autogenerated input type of CreateUserMutation */
export type CreateUserMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: UserInput;
};

/** Autogenerated return type of CreateUserMutation */
export type CreateUserMutationPayload = {
  __typename?: 'CreateUserMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  user: User;
};

export type CreateVoteInput = {
  id: Scalars['ID'];
  voteType: VoteTypeEnum;
};

/** Autogenerated input type of CreateWorkExperienceMutation */
export type CreateWorkExperienceMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: WorkExperienceInput;
};

/** Autogenerated return type of CreateWorkExperienceMutation */
export type CreateWorkExperienceMutationPayload = {
  __typename?: 'CreateWorkExperienceMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  workExperience: WorkExperience;
};

export enum DegreeClassificationEnum {
  Excellent = 'EXCELLENT',
  Good = 'GOOD',
  NotGraduated = 'NOT_GRADUATED',
  Ordinary = 'ORDINARY',
  VeryGood = 'VERY_GOOD'
}

/** Autogenerated input type of DeleteCategoriesMutation */
export type DeleteCategoriesMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteCategoriesMutation */
export type DeleteCategoriesMutationPayload = {
  __typename?: 'DeleteCategoriesMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteCategoryMutation */
export type DeleteCategoryMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteCategoryMutation */
export type DeleteCategoryMutationPayload = {
  __typename?: 'DeleteCategoryMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteCodingExamsMutation */
export type DeleteCodingExamsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteCodingExamsMutation */
export type DeleteCodingExamsMutationPayload = {
  __typename?: 'DeleteCodingExamsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteCommentsMutation */
export type DeleteCommentsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteCommentsMutation */
export type DeleteCommentsMutationPayload = {
  __typename?: 'DeleteCommentsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteCourseLessonsMutation */
export type DeleteCourseLessonsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteCourseLessonsMutation */
export type DeleteCourseLessonsMutationPayload = {
  __typename?: 'DeleteCourseLessonsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteCourseMutation */
export type DeleteCourseMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteCourseMutation */
export type DeleteCourseMutationPayload = {
  __typename?: 'DeleteCourseMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteCoursesMutation */
export type DeleteCoursesMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteCoursesMutation */
export type DeleteCoursesMutationPayload = {
  __typename?: 'DeleteCoursesMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteDirectoriesMutation */
export type DeleteDirectoriesMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteDirectoriesMutation */
export type DeleteDirectoriesMutationPayload = {
  __typename?: 'DeleteDirectoriesMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteDirectoryMutation */
export type DeleteDirectoryMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteDirectoryMutation */
export type DeleteDirectoryMutationPayload = {
  __typename?: 'DeleteDirectoryMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteEducationsMutation */
export type DeleteEducationsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteEducationsMutation */
export type DeleteEducationsMutationPayload = {
  __typename?: 'DeleteEducationsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteFaqAnswersMutation */
export type DeleteFaqAnswersMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteFaqAnswersMutation */
export type DeleteFaqAnswersMutationPayload = {
  __typename?: 'DeleteFaqAnswersMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteFaqsMutation */
export type DeleteFaqsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteFaqsMutation */
export type DeleteFaqsMutationPayload = {
  __typename?: 'DeleteFaqsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteGapFillExamsMutation */
export type DeleteGapFillExamsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteGapFillExamsMutation */
export type DeleteGapFillExamsMutationPayload = {
  __typename?: 'DeleteGapFillExamsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteLearningPathsMutation */
export type DeleteLearningPathsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteLearningPathsMutation */
export type DeleteLearningPathsMutationPayload = {
  __typename?: 'DeleteLearningPathsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteOrganizedExamsMutation */
export type DeleteOrganizedExamsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteOrganizedExamsMutation */
export type DeleteOrganizedExamsMutationPayload = {
  __typename?: 'DeleteOrganizedExamsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeletePostMutation */
export type DeletePostMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeletePostMutation */
export type DeletePostMutationPayload = {
  __typename?: 'DeletePostMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  status: Scalars['String'];
};

/** Autogenerated input type of DeletePostsMutation */
export type DeletePostsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeletePostsMutation */
export type DeletePostsMutationPayload = {
  __typename?: 'DeletePostsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeletePracticesMutation */
export type DeletePracticesMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeletePracticesMutation */
export type DeletePracticesMutationPayload = {
  __typename?: 'DeletePracticesMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeletePublicFileMutation */
export type DeletePublicFileMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeletePublicFileMutation */
export type DeletePublicFileMutationPayload = {
  __typename?: 'DeletePublicFileMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeletePublicFilesMutation */
export type DeletePublicFilesMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeletePublicFilesMutation */
export type DeletePublicFilesMutationPayload = {
  __typename?: 'DeletePublicFilesMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteQuizExamsMutation */
export type DeleteQuizExamsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteQuizExamsMutation */
export type DeleteQuizExamsMutationPayload = {
  __typename?: 'DeleteQuizExamsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteQuizQuestsMutation */
export type DeleteQuizQuestsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteQuizQuestsMutation */
export type DeleteQuizQuestsMutationPayload = {
  __typename?: 'DeleteQuizQuestsMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteUsersMutation */
export type DeleteUsersMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteUsersMutation */
export type DeleteUsersMutationPayload = {
  __typename?: 'DeleteUsersMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteWorkExperiencesMutation */
export type DeleteWorkExperiencesMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteWorkExperiencesMutation */
export type DeleteWorkExperiencesMutationPayload = {
  __typename?: 'DeleteWorkExperiencesMutationPayload';
  affectedIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

export enum DifficultyEnum {
  AllScopes = 'ALL_SCOPES',
  Beginner = 'BEGINNER',
  Expert = 'EXPERT',
  Intermediate = 'INTERMEDIATE'
}

export type Directory = ActiveRecordInterface & {
  __typename?: 'Directory';
  ancestry?: Maybe<Scalars['String']>;
  children?: Maybe<Array<Directory>>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  owner: User;
  publicFiles?: Maybe<PublicFilesResolversSearchResult>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type DirectoryPublicFilesArgs = {
  acceptedTypes?: InputMaybe<Array<AcceptedTypeEnum>>;
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type DirectoryInput = {
  /** Name */
  name: Scalars['String'];
  /** Parent Id */
  parentId: Scalars['ID'];
};

export type Education = ActiveRecordInterface & {
  __typename?: 'Education';
  concentration?: Maybe<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  degreeClassification?: Maybe<DegreeClassificationEnum>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['ISO8601DateTime']>;
  id: Scalars['ID'];
  school: Scalars['String'];
  startDate?: Maybe<Scalars['ISO8601DateTime']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type EducationInput = {
  concentration?: InputMaybe<Scalars['String']>;
  degreeClassification?: InputMaybe<DegreeClassificationEnum>;
  description?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['ISO8601DateTime']>;
  school: Scalars['String'];
  startDate?: InputMaybe<Scalars['ISO8601DateTime']>;
};

export type ExamSubmissionInterface = {
  correctRatio?: Maybe<Scalars['Float']>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  owner: User;
  stat?: Maybe<ExamSubmissionStat>;
  totalPoints?: Maybe<Scalars['Float']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type ExamSubmissionStat = {
  __typename?: 'ExamSubmissionStat';
  correctCount: Scalars['Int'];
  totalCount: Scalars['Int'];
};

/** Exam Submission Union */
export type ExamSubmissionUnion = CodingExamSubmission | GapFillExamSubmission;

export type Faq = ActiveRecordInterface & {
  __typename?: 'Faq';
  answers: FaqAnswersResolversSearchResult;
  content?: Maybe<Scalars['String']>;
  contentHtml?: Maybe<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  faqAnswersCount: Scalars['Int'];
  id: Scalars['ID'];
  isAnswered: Scalars['Boolean'];
  isBounty: Scalars['Boolean'];
  isSolved: Scalars['Boolean'];
  latestAnsweredAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** vote mà bạn đã cho */
  ownedVote?: Maybe<Vote>;
  owner: User;
  slug?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  votes: Array<Vote>;
  votesSum?: Maybe<Scalars['Int']>;
};

export type FaqAnswersArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type FaqAnswer = ActiveRecordInterface & {
  __typename?: 'FaqAnswer';
  children: FaqAnswerChildrenSearchResult;
  content?: Maybe<Scalars['String']>;
  contentHtml?: Maybe<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  faqId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  isAccepted: Scalars['Boolean'];
  ownedVote?: Maybe<Vote>;
  owner: User;
  updatedAt: Scalars['ISO8601DateTime'];
  votes: Array<Vote>;
  votesSum?: Maybe<Scalars['Int']>;
};

export type FaqAnswerChildrenArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type FaqAnswerChildrenSearchResult = {
  __typename?: 'FaqAnswerChildrenSearchResult';
  node: Array<FaqAnswer>;
  pageInfo: Result;
};

export type FaqAnswerInput = {
  content: Scalars['String'];
  contentHtml: Scalars['String'];
  faqId: Scalars['Int'];
  parentId?: InputMaybe<Scalars['ID']>;
};

export type FaqAnswersResolversSearchResult = {
  __typename?: 'FaqAnswersResolversSearchResult';
  node: Array<FaqAnswer>;
  pageInfo: Result;
};

export type FaqInput = {
  content: Scalars['String'];
  contentHtml: Scalars['String'];
  isBounty?: InputMaybe<Scalars['Boolean']>;
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  title: Scalars['String'];
};

export type FaqsSearchResult = {
  __typename?: 'FaqsSearchResult';
  node: Array<Faq>;
  pageInfo: Result;
};

export type FavoriteCourse = ActiveRecordInterface & {
  __typename?: 'FavoriteCourse';
  course: Course;
  courseId: Scalars['ID'];
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  updatedAt: Scalars['ISO8601DateTime'];
  userId: Scalars['ID'];
};

export type FavoriteCourseInput = {
  courseId: Scalars['ID'];
};

export type GapFillExam = SectionItemInterface & {
  __typename?: 'GapFillExam';
  content: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  /** Mô tả */
  description?: Maybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: Maybe<DifficultyEnum>;
  gapValues: Array<Scalars['String']>;
  id: Scalars['ID'];
  /** Đã hoàn thành */
  isCompleted: Scalars['Boolean'];
  isIgnoreCase: Scalars['Boolean'];
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  owner?: Maybe<User>;
  slug?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  title: Scalars['String'];
  topicSection?: Maybe<TopicSection>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type GapFillExamTopicSectionArgs = {
  programId: Scalars['ID'];
};

export type GapFillExamJudgedResult = {
  __typename?: 'GapFillExamJudgedResult';
  index: Scalars['Int'];
  isCorrect: Scalars['Boolean'];
};

export type GapFillExamSubmission = ExamSubmissionInterface & {
  __typename?: 'GapFillExamSubmission';
  correctRatio?: Maybe<Scalars['Float']>;
  createdAt: Scalars['ISO8601DateTime'];
  filledValues?: Maybe<Array<Scalars['String']>>;
  id: Scalars['ID'];
  judgedResult?: Maybe<Array<GapFillExamJudgedResult>>;
  owner: User;
  stat?: Maybe<ExamSubmissionStat>;
  totalPoints?: Maybe<Scalars['Float']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type GapFillExamSubmissionInput = {
  filledValues: Array<Scalars['String']>;
  gapFillExamId: Scalars['ID'];
  programId: Scalars['ID'];
};

export type GapFillExamsSearchResult = {
  __typename?: 'GapFillExamsSearchResult';
  node: Array<GapFillExam>;
  pageInfo: Result;
};

export type JdoodleExecuteInput = {
  language: Scalars['String'];
  script: Scalars['String'];
  stdin?: InputMaybe<Scalars['String']>;
  versionIndex: Scalars['String'];
};

/** Autogenerated input type of JdoodleExecuteMutation */
export type JdoodleExecuteMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: JdoodleExecuteInput;
};

/** Autogenerated return type of JdoodleExecuteMutation */
export type JdoodleExecuteMutationPayload = {
  __typename?: 'JdoodleExecuteMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  response: JdoodleExecuteResponse;
};

export type JdoodleExecuteResponse = {
  __typename?: 'JdoodleExecuteResponse';
  body: Scalars['JSON'];
  status: Scalars['Int'];
};

export type JobQuizOption = ActiveRecordInterface & {
  __typename?: 'JobQuizOption';
  content: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  personalityIds: Array<Scalars['ID']>;
  rowOrder: Scalars['Int'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type JobQuizQuestion = ActiveRecordInterface & {
  __typename?: 'JobQuizQuestion';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  jobQuizOptions: Array<JobQuizOption>;
  nextQuestion?: Maybe<JobQuizQuestion>;
  rowOrder: Scalars['Int'];
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type JobQuizQuestionInput = {
  /** Danh sách options của question */
  jobQuizOptionsAttributes?: InputMaybe<Array<CreateJobQuizOptionInput>>;
  rowOrderPosition: Scalars['Int'];
  /** Title */
  title: Scalars['String'];
};

export type JobQuizQuestionsSearchResult = {
  __typename?: 'JobQuizQuestionsSearchResult';
  node: Array<JobQuizQuestion>;
  pageInfo: Result;
};

/** Autogenerated input type of JoinLearningPathMutation */
export type JoinLearningPathMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  learningPathId: Scalars['ID'];
};

/** Autogenerated return type of JoinLearningPathMutation */
export type JoinLearningPathMutationPayload = {
  __typename?: 'JoinLearningPathMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of JoinProgramMutation */
export type JoinProgramMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: ProgramsUserInput;
};

/** Autogenerated return type of JoinProgramMutation */
export type JoinProgramMutationPayload = {
  __typename?: 'JoinProgramMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  programsUser: ProgramsUser;
};

export type Language = ActiveRecordInterface & {
  __typename?: 'Language';
  canJudge: Scalars['Boolean'];
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  reactAceKey?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type LearningPath = ActiveRecordInterface & {
  __typename?: 'LearningPath';
  benefits?: Maybe<Scalars['JSON']>;
  benefitsSummary?: Maybe<Scalars['JSON']>;
  cover?: Maybe<PublicFile>;
  coverId?: Maybe<Scalars['Int']>;
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  difficulty: DifficultyEnum;
  duration?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  includes?: Maybe<Scalars['String']>;
  isJoined: Scalars['Boolean'];
  learningPathsPrograms: Array<LearningPathsProgram>;
  meta?: Maybe<Scalars['JSON']>;
  /** Phần trăm tiến độ */
  ownedProgress?: Maybe<Scalars['Float']>;
  owner: User;
  ownerId?: Maybe<Scalars['Int']>;
  projects?: Maybe<Scalars['JSON']>;
  reading?: Maybe<LearningPathReading>;
  slug: Scalars['String'];
  summary?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  target?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type LearningPathReading = {
  __typename?: 'LearningPathReading';
  courseSlug: Scalars['String'];
  sectionItemSlug: Scalars['String'];
};

export type LearningPathSuggestion = ActiveRecordInterface & {
  __typename?: 'LearningPathSuggestion';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  learningPath: LearningPath;
  rowOrder?: Maybe<Scalars['Int']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type LearningPathSuggestionInput = {
  /** Bỏ trống để tạo mới */
  id?: InputMaybe<Scalars['ID']>;
  learningPathId: Scalars['ID'];
  rowOrderPosition: Scalars['Int'];
  /** Set = true để xóa */
  willDestroy?: InputMaybe<Scalars['Boolean']>;
};

export type LearningPathsProgram = ActiveRecordInterface & {
  __typename?: 'LearningPathsProgram';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  program: Course;
  rowOrder?: Maybe<Scalars['Int']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type LearningPathsSearchResult = {
  __typename?: 'LearningPathsSearchResult';
  node: Array<LearningPath>;
  pageInfo: Result;
};

/** Autogenerated input type of LeaveProgramMutation */
export type LeaveProgramMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: ProgramsUserInput;
};

/** Autogenerated return type of LeaveProgramMutation */
export type LeaveProgramMutationPayload = {
  __typename?: 'LeaveProgramMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  status: Scalars['String'];
};

export type LoginInput = {
  /** Email */
  email: Scalars['String'];
  /** Password */
  password: Scalars['String'];
};

/** Autogenerated input type of LoginMutation */
export type LoginMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: LoginInput;
};

/** Autogenerated return type of LoginMutation */
export type LoginMutationPayload = {
  __typename?: 'LoginMutationPayload';
  authorization: Authorization;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  acceptFaqAnswer?: Maybe<AcceptFaqAnswerMutationPayload>;
  calculateJobQuizPoint?: Maybe<CalculateJobQuizPointMutationPayload>;
  changePassword?: Maybe<ChangePasswordMutationPayload>;
  confirmEmail?: Maybe<ConfirmEmailMutationPayload>;
  createCategory?: Maybe<CreateCategoryMutationPayload>;
  createCodeSuggestionRequest?: Maybe<CreateCodeSuggestionRequestMutationPayload>;
  createCodingExam?: Maybe<CreateCodingExamMutationPayload>;
  createCodingExamSubmission?: Maybe<CreateCodingExamSubmissionMutationPayload>;
  createComment?: Maybe<CreateCommentMutationPayload>;
  createCourse?: Maybe<CreateCourseMutationPayload>;
  createCourseLesson?: Maybe<CreateCourseLessonMutationPayload>;
  createDirectory?: Maybe<CreateDirectoryMutationPayload>;
  createEducation?: Maybe<CreateEducationMutationPayload>;
  createFaq?: Maybe<CreateFaqMutationPayload>;
  createFaqAnswer?: Maybe<CreateFaqAnswerMutationPayload>;
  createFavoriteCourse?: Maybe<CreateFavoriteCourseMutationPayload>;
  createGapFillExam?: Maybe<CreateGapFillExamMutationPayload>;
  createGapFillExamSubmission?: Maybe<CreateGapFillExamSubmissionMutationPayload>;
  createLearningPath?: Maybe<CreateLearningPathMutationPayload>;
  createOrganizedExam?: Maybe<CreateOrganizedExamMutationPayload>;
  createOrganizedExamSubmission?: Maybe<CreateOrganizedExamSubmissionMutationPayload>;
  createPost?: Maybe<CreatePostMutationPayload>;
  createPractice?: Maybe<CreatePracticeMutationPayload>;
  createPublicFile?: Maybe<CreatePublicFileMutationPayload>;
  createQuizExam?: Maybe<CreateQuizExamMutationPayload>;
  createQuizExamSubmission?: Maybe<CreateQuizExamSubmissionMutationPayload>;
  createQuizQuest?: Maybe<CreateQuizQuestMutationPayload>;
  createUser?: Maybe<CreateUserMutationPayload>;
  createWorkExperience?: Maybe<CreateWorkExperienceMutationPayload>;
  deleteCategories?: Maybe<DeleteCategoriesMutationPayload>;
  deleteCategory?: Maybe<DeleteCategoryMutationPayload>;
  deleteCodingExams?: Maybe<DeleteCodingExamsMutationPayload>;
  deleteComments?: Maybe<DeleteCommentsMutationPayload>;
  deleteCourse?: Maybe<DeleteCourseMutationPayload>;
  deleteCourseLessons?: Maybe<DeleteCourseLessonsMutationPayload>;
  deleteCourses?: Maybe<DeleteCoursesMutationPayload>;
  deleteDirectories?: Maybe<DeleteDirectoriesMutationPayload>;
  deleteDirectory?: Maybe<DeleteDirectoryMutationPayload>;
  deleteEducations?: Maybe<DeleteEducationsMutationPayload>;
  deleteFaqAnswers?: Maybe<DeleteFaqAnswersMutationPayload>;
  deleteFaqs?: Maybe<DeleteFaqsMutationPayload>;
  deleteGapFillExams?: Maybe<DeleteGapFillExamsMutationPayload>;
  deleteLearningPaths?: Maybe<DeleteLearningPathsMutationPayload>;
  deleteOrganizedExams?: Maybe<DeleteOrganizedExamsMutationPayload>;
  deletePost?: Maybe<DeletePostMutationPayload>;
  deletePosts?: Maybe<DeletePostsMutationPayload>;
  deletePractices?: Maybe<DeletePracticesMutationPayload>;
  deletePublicFile?: Maybe<DeletePublicFileMutationPayload>;
  deletePublicFiles?: Maybe<DeletePublicFilesMutationPayload>;
  deleteQuizExams?: Maybe<DeleteQuizExamsMutationPayload>;
  deleteQuizQuests?: Maybe<DeleteQuizQuestsMutationPayload>;
  deleteUsers?: Maybe<DeleteUsersMutationPayload>;
  deleteWorkExperiences?: Maybe<DeleteWorkExperiencesMutationPayload>;
  jdoodleExecute?: Maybe<JdoodleExecuteMutationPayload>;
  joinLearningPath?: Maybe<JoinLearningPathMutationPayload>;
  joinProgram?: Maybe<JoinProgramMutationPayload>;
  leaveProgram?: Maybe<LeaveProgramMutationPayload>;
  login?: Maybe<LoginMutationPayload>;
  removeCoursesFromFavorite?: Maybe<RemoveCoursesFromFavoriteMutationPayload>;
  resetPassword?: Maybe<ResetPasswordMutationPayload>;
  sendConfirmationEmail?: Maybe<SendConfirmationEmailMutationPayload>;
  sendResetPasswordEmail?: Maybe<SendResetPasswordEmailMutationPayload>;
  signUp?: Maybe<SignUpMutationPayload>;
  updateCategory?: Maybe<UpdateCategoryMutationPayload>;
  updateCodingExam?: Maybe<UpdateCodingExamMutationPayload>;
  updateComment?: Maybe<UpdateCommentMutationPayload>;
  updateCourse?: Maybe<UpdateCourseMutationPayload>;
  updateCourseLesson?: Maybe<UpdateCourseLessonMutationPayload>;
  updateDirectory?: Maybe<UpdateDirectoryMutationPayload>;
  updateEducation?: Maybe<UpdateEducationMutationPayload>;
  updateFaq?: Maybe<UpdateFaqMutationPayload>;
  updateFaqAnswer?: Maybe<UpdateFaqAnswerMutationPayload>;
  updateGapFillExam?: Maybe<UpdateGapFillExamMutationPayload>;
  updateJobQuizQuestions?: Maybe<UpdateJobQuizQuestionsMutationPayload>;
  updateLearningPath?: Maybe<UpdateLearningPathMutationPayload>;
  updateOrganizedExam?: Maybe<UpdateOrganizedExamMutationPayload>;
  updatePersonality?: Maybe<UpdatePersonalityMutationPayload>;
  updatePost?: Maybe<UpdatePostMutationPayload>;
  updatePractice?: Maybe<UpdatePracticeMutationPayload>;
  updateProfile?: Maybe<UpdateProfileMutationPayload>;
  updatePublicFile?: Maybe<UpdatePublicFileMutationPayload>;
  updateQuizExam?: Maybe<UpdateQuizExamMutationPayload>;
  updateQuizQuest?: Maybe<UpdateQuizQuestMutationPayload>;
  updateUser?: Maybe<UpdateUserMutationPayload>;
  updateUserRole?: Maybe<UpdateUserRoleMutationPayload>;
  updateWorkExperience?: Maybe<UpdateWorkExperienceMutationPayload>;
  viewTopicSection?: Maybe<ViewTopicSectionMutationPayload>;
  voteComment?: Maybe<VoteCommentMutationPayload>;
  voteFaq?: Maybe<VoteFaqMutationPayload>;
  voteFaqAnswer?: Maybe<VoteFaqAnswerMutationPayload>;
  votePost?: Maybe<VotePostMutationPayload>;
};

export type MutationAcceptFaqAnswerArgs = {
  input: AcceptFaqAnswerMutationInput;
};

export type MutationCalculateJobQuizPointArgs = {
  input: CalculateJobQuizPointMutationInput;
};

export type MutationChangePasswordArgs = {
  input: ChangePasswordMutationInput;
};

export type MutationConfirmEmailArgs = {
  input: ConfirmEmailMutationInput;
};

export type MutationCreateCategoryArgs = {
  input: CreateCategoryMutationInput;
};

export type MutationCreateCodeSuggestionRequestArgs = {
  input: CreateCodeSuggestionRequestMutationInput;
};

export type MutationCreateCodingExamArgs = {
  input: CreateCodingExamMutationInput;
};

export type MutationCreateCodingExamSubmissionArgs = {
  input: CreateCodingExamSubmissionMutationInput;
};

export type MutationCreateCommentArgs = {
  input: CreateCommentMutationInput;
};

export type MutationCreateCourseArgs = {
  input: CreateCourseMutationInput;
};

export type MutationCreateCourseLessonArgs = {
  input: CreateCourseLessonMutationInput;
};

export type MutationCreateDirectoryArgs = {
  input: CreateDirectoryMutationInput;
};

export type MutationCreateEducationArgs = {
  input: CreateEducationMutationInput;
};

export type MutationCreateFaqArgs = {
  input: CreateFaqMutationInput;
};

export type MutationCreateFaqAnswerArgs = {
  input: CreateFaqAnswerMutationInput;
};

export type MutationCreateFavoriteCourseArgs = {
  input: CreateFavoriteCourseMutationInput;
};

export type MutationCreateGapFillExamArgs = {
  input: CreateGapFillExamMutationInput;
};

export type MutationCreateGapFillExamSubmissionArgs = {
  input: CreateGapFillExamSubmissionMutationInput;
};

export type MutationCreateLearningPathArgs = {
  input: CreateLearningPathMutationInput;
};

export type MutationCreateOrganizedExamArgs = {
  input: CreateOrganizedExamMutationInput;
};

export type MutationCreateOrganizedExamSubmissionArgs = {
  input: CreateOrganizedExamSubmissionMutationInput;
};

export type MutationCreatePostArgs = {
  input: CreatePostMutationInput;
};

export type MutationCreatePracticeArgs = {
  input: CreatePracticeMutationInput;
};

export type MutationCreatePublicFileArgs = {
  input: CreatePublicFileMutationInput;
};

export type MutationCreateQuizExamArgs = {
  input: CreateQuizExamMutationInput;
};

export type MutationCreateQuizExamSubmissionArgs = {
  input: CreateQuizExamSubmissionMutationInput;
};

export type MutationCreateQuizQuestArgs = {
  input: CreateQuizQuestMutationInput;
};

export type MutationCreateUserArgs = {
  input: CreateUserMutationInput;
};

export type MutationCreateWorkExperienceArgs = {
  input: CreateWorkExperienceMutationInput;
};

export type MutationDeleteCategoriesArgs = {
  input: DeleteCategoriesMutationInput;
};

export type MutationDeleteCategoryArgs = {
  input: DeleteCategoryMutationInput;
};

export type MutationDeleteCodingExamsArgs = {
  input: DeleteCodingExamsMutationInput;
};

export type MutationDeleteCommentsArgs = {
  input: DeleteCommentsMutationInput;
};

export type MutationDeleteCourseArgs = {
  input: DeleteCourseMutationInput;
};

export type MutationDeleteCourseLessonsArgs = {
  input: DeleteCourseLessonsMutationInput;
};

export type MutationDeleteCoursesArgs = {
  input: DeleteCoursesMutationInput;
};

export type MutationDeleteDirectoriesArgs = {
  input: DeleteDirectoriesMutationInput;
};

export type MutationDeleteDirectoryArgs = {
  input: DeleteDirectoryMutationInput;
};

export type MutationDeleteEducationsArgs = {
  input: DeleteEducationsMutationInput;
};

export type MutationDeleteFaqAnswersArgs = {
  input: DeleteFaqAnswersMutationInput;
};

export type MutationDeleteFaqsArgs = {
  input: DeleteFaqsMutationInput;
};

export type MutationDeleteGapFillExamsArgs = {
  input: DeleteGapFillExamsMutationInput;
};

export type MutationDeleteLearningPathsArgs = {
  input: DeleteLearningPathsMutationInput;
};

export type MutationDeleteOrganizedExamsArgs = {
  input: DeleteOrganizedExamsMutationInput;
};

export type MutationDeletePostArgs = {
  input: DeletePostMutationInput;
};

export type MutationDeletePostsArgs = {
  input: DeletePostsMutationInput;
};

export type MutationDeletePracticesArgs = {
  input: DeletePracticesMutationInput;
};

export type MutationDeletePublicFileArgs = {
  input: DeletePublicFileMutationInput;
};

export type MutationDeletePublicFilesArgs = {
  input: DeletePublicFilesMutationInput;
};

export type MutationDeleteQuizExamsArgs = {
  input: DeleteQuizExamsMutationInput;
};

export type MutationDeleteQuizQuestsArgs = {
  input: DeleteQuizQuestsMutationInput;
};

export type MutationDeleteUsersArgs = {
  input: DeleteUsersMutationInput;
};

export type MutationDeleteWorkExperiencesArgs = {
  input: DeleteWorkExperiencesMutationInput;
};

export type MutationJdoodleExecuteArgs = {
  input: JdoodleExecuteMutationInput;
};

export type MutationJoinLearningPathArgs = {
  input: JoinLearningPathMutationInput;
};

export type MutationJoinProgramArgs = {
  input: JoinProgramMutationInput;
};

export type MutationLeaveProgramArgs = {
  input: LeaveProgramMutationInput;
};

export type MutationLoginArgs = {
  input: LoginMutationInput;
};

export type MutationRemoveCoursesFromFavoriteArgs = {
  input: RemoveCoursesFromFavoriteMutationInput;
};

export type MutationResetPasswordArgs = {
  input: ResetPasswordMutationInput;
};

export type MutationSendConfirmationEmailArgs = {
  input: SendConfirmationEmailMutationInput;
};

export type MutationSendResetPasswordEmailArgs = {
  input: SendResetPasswordEmailMutationInput;
};

export type MutationSignUpArgs = {
  input: SignUpMutationInput;
};

export type MutationUpdateCategoryArgs = {
  input: UpdateCategoryMutationInput;
};

export type MutationUpdateCodingExamArgs = {
  input: UpdateCodingExamMutationInput;
};

export type MutationUpdateCommentArgs = {
  input: UpdateCommentMutationInput;
};

export type MutationUpdateCourseArgs = {
  input: UpdateCourseMutationInput;
};

export type MutationUpdateCourseLessonArgs = {
  input: UpdateCourseLessonMutationInput;
};

export type MutationUpdateDirectoryArgs = {
  input: UpdateDirectoryMutationInput;
};

export type MutationUpdateEducationArgs = {
  input: UpdateEducationMutationInput;
};

export type MutationUpdateFaqArgs = {
  input: UpdateFaqMutationInput;
};

export type MutationUpdateFaqAnswerArgs = {
  input: UpdateFaqAnswerMutationInput;
};

export type MutationUpdateGapFillExamArgs = {
  input: UpdateGapFillExamMutationInput;
};

export type MutationUpdateJobQuizQuestionsArgs = {
  input: UpdateJobQuizQuestionsMutationInput;
};

export type MutationUpdateLearningPathArgs = {
  input: UpdateLearningPathMutationInput;
};

export type MutationUpdateOrganizedExamArgs = {
  input: UpdateOrganizedExamMutationInput;
};

export type MutationUpdatePersonalityArgs = {
  input: UpdatePersonalityMutationInput;
};

export type MutationUpdatePostArgs = {
  input: UpdatePostMutationInput;
};

export type MutationUpdatePracticeArgs = {
  input: UpdatePracticeMutationInput;
};

export type MutationUpdateProfileArgs = {
  input: UpdateProfileMutationInput;
};

export type MutationUpdatePublicFileArgs = {
  input: UpdatePublicFileMutationInput;
};

export type MutationUpdateQuizExamArgs = {
  input: UpdateQuizExamMutationInput;
};

export type MutationUpdateQuizQuestArgs = {
  input: UpdateQuizQuestMutationInput;
};

export type MutationUpdateUserArgs = {
  input: UpdateUserMutationInput;
};

export type MutationUpdateUserRoleArgs = {
  input: UpdateUserRoleMutationInput;
};

export type MutationUpdateWorkExperienceArgs = {
  input: UpdateWorkExperienceMutationInput;
};

export type MutationViewTopicSectionArgs = {
  input: ViewTopicSectionMutationInput;
};

export type MutationVoteCommentArgs = {
  input: VoteCommentMutationInput;
};

export type MutationVoteFaqArgs = {
  input: VoteFaqMutationInput;
};

export type MutationVoteFaqAnswerArgs = {
  input: VoteFaqAnswerMutationInput;
};

export type MutationVotePostArgs = {
  input: VotePostMutationInput;
};

export type OrganizedExam = SectionItemInterface & {
  __typename?: 'OrganizedExam';
  allowList: Array<Scalars['String']>;
  canRunCode: Scalars['Boolean'];
  content: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  denyList: Array<Scalars['String']>;
  /** Mô tả */
  description?: Maybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: Maybe<DifficultyEnum>;
  id: Scalars['ID'];
  /** Đã hoàn thành */
  isCompleted: Scalars['Boolean'];
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  owner?: Maybe<User>;
  slug?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  title: Scalars['String'];
  topicSection?: Maybe<TopicSection>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type OrganizedExamTopicSectionArgs = {
  programId: Scalars['ID'];
};

export type OrganizedExamMistake = {
  __typename?: 'OrganizedExamMistake';
  missingKeyword?: Maybe<Scalars['String']>;
  prohibitKeywords: Array<Scalars['String']>;
};

export type OrganizedExamSubmission = ExamSubmissionInterface & {
  __typename?: 'OrganizedExamSubmission';
  content: Scalars['String'];
  correctRatio?: Maybe<Scalars['Float']>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  mistake?: Maybe<OrganizedExamMistake>;
  owner: User;
  stat?: Maybe<ExamSubmissionStat>;
  totalPoints?: Maybe<Scalars['Float']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type OrganizedExamSubmissionInput = {
  content: Scalars['String'];
  organizedExamId: Scalars['ID'];
  programId: Scalars['ID'];
};

export type OrganizedExamsSearchResult = {
  __typename?: 'OrganizedExamsSearchResult';
  node: Array<OrganizedExam>;
  pageInfo: Result;
};

export type OwnedCertificatesSearchResult = {
  __typename?: 'OwnedCertificatesSearchResult';
  node: Array<UserCertificate>;
  pageInfo: Result;
};

export type OwnedFavoriteCoursesSearchResult = {
  __typename?: 'OwnedFavoriteCoursesSearchResult';
  node: Array<FavoriteCourse>;
  pageInfo: Result;
};

export type PaginateInput = {
  /** Page number */
  page?: InputMaybe<Scalars['Int']>;
  /** Number of nodes per page */
  perPage?: InputMaybe<Scalars['Int']>;
};

export type PersonalitiesSearchResult = {
  __typename?: 'PersonalitiesSearchResult';
  node: Array<Personality>;
  pageInfo: Result;
};

export type Personality = ActiveRecordInterface & {
  __typename?: 'Personality';
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  image?: Maybe<PublicFile>;
  imageId?: Maybe<Scalars['ID']>;
  learningPathSuggestions: Array<LearningPathSuggestion>;
  name?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type PersonalityInput = {
  description?: InputMaybe<Scalars['String']>;
  imageId?: InputMaybe<Scalars['ID']>;
  learningPathSuggestionsAttributes?: InputMaybe<Array<LearningPathSuggestionInput>>;
  name?: InputMaybe<Scalars['String']>;
};

export type Post = ActiveRecordInterface & {
  __typename?: 'Post';
  categories: Array<Category>;
  comments: Array<Comment>;
  content: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  meta?: Maybe<Scalars['JSON']>;
  ownedVote?: Maybe<Vote>;
  owner?: Maybe<User>;
  relatedBridges: Array<RelatedBridge>;
  slug?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  thumbnail?: Maybe<PublicFile>;
  title: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
  viewsCount: Scalars['Int'];
  votes: Array<Vote>;
  votesSum?: Maybe<Scalars['Int']>;
};

export type PostsSearchResult = {
  __typename?: 'PostsSearchResult';
  node: Array<Post>;
  pageInfo: Result;
};

export type Practice = ActiveRecordInterface & {
  __typename?: 'Practice';
  categories: Array<Category>;
  comments: Array<Comment>;
  cover?: Maybe<PublicFile>;
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  difficulty?: Maybe<DifficultyEnum>;
  duration?: Maybe<Scalars['Int']>;
  examsCount: Scalars['Int'];
  haveCertificate: Scalars['Boolean'];
  id: Scalars['ID'];
  isDraft?: Maybe<Scalars['Boolean']>;
  isFavorite?: Maybe<Scalars['Boolean']>;
  isFeatured?: Maybe<Scalars['Boolean']>;
  /** Check xem user hiện tại đã join vào program này chưa */
  isJoined?: Maybe<Scalars['Boolean']>;
  isTrending?: Maybe<Scalars['Boolean']>;
  languages: Array<Language>;
  lessonsCount?: Maybe<Scalars['Int']>;
  meta?: Maybe<Scalars['JSON']>;
  /** Phần trăm tiến độ */
  ownedProgress?: Maybe<Scalars['Float']>;
  owner: User;
  programsUsersCount: Scalars['Int'];
  readingTopicSection?: Maybe<TopicSection>;
  slug?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  title?: Maybe<Scalars['String']>;
  topics?: Maybe<Array<Topic>>;
  totalPoints: Scalars['Int'];
  updatedAt: Scalars['ISO8601DateTime'];
  viewsCount: Scalars['Int'];
};

export type PracticeRankListsSearchResult = {
  __typename?: 'PracticeRankListsSearchResult';
  node: Array<User>;
  pageInfo: Result;
};

export type PracticeStat = {
  __typename?: 'PracticeStat';
  ownedPoints?: Maybe<Scalars['Float']>;
  totalPoints?: Maybe<Scalars['Float']>;
};

export type PracticesSearchResult = {
  __typename?: 'PracticesSearchResult';
  node: Array<Practice>;
  pageInfo: Result;
};

export type ProgramsUser = ActiveRecordInterface & {
  __typename?: 'ProgramsUser';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  programId: Scalars['ID'];
  totalPoints: Scalars['Float'];
  updatedAt: Scalars['ISO8601DateTime'];
  user: User;
  userId: Scalars['ID'];
};

export type ProgramsUserInput = {
  programId: Scalars['ID'];
};

export type PublicFile = ActiveRecordInterface & {
  __typename?: 'PublicFile';
  createdAt: Scalars['ISO8601DateTime'];
  directory: Directory;
  directoryId: Scalars['ID'];
  downloadUrl: Scalars['String'];
  filename: Scalars['String'];
  id: Scalars['ID'];
  metadata: Scalars['JSON'];
  owner: User;
  thumbnailUrl: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type PublicFilesResolversSearchResult = {
  __typename?: 'PublicFilesResolversSearchResult';
  node: Array<PublicFile>;
  pageInfo: Result;
};

export type Query = {
  __typename?: 'Query';
  allLanguages: Array<Language>;
  categories: CategoriesSearchResult;
  codingExam: CodingExam;
  codingExams: CodingExamsSearchResult;
  course: Course;
  courseCertificates: CourseCertificatesSearchResult;
  courseLesson: CourseLesson;
  courseLessons: CourseLessonsSearchResult;
  courses: CoursesSearchResult;
  directory: Directory;
  faq: Faq;
  faqAnswer: FaqAnswer;
  faqs: FaqsSearchResult;
  firstJobQuizQuestion: JobQuizQuestion;
  gapFillExam: GapFillExam;
  gapFillExams: GapFillExamsSearchResult;
  jobQuizQuestion: JobQuizQuestion;
  jobQuizQuestions: JobQuizQuestionsSearchResult;
  learningPath: LearningPath;
  learningPaths: LearningPathsSearchResult;
  me: User;
  organizedExam: OrganizedExam;
  organizedExams: OrganizedExamsSearchResult;
  ownedCertificates: OwnedCertificatesSearchResult;
  ownedCourses?: Maybe<Array<Course>>;
  ownedFavoriteCourses: OwnedFavoriteCoursesSearchResult;
  ownedPracticeStat?: Maybe<PracticeStat>;
  personalities: PersonalitiesSearchResult;
  personality: Personality;
  post: Post;
  posts: PostsSearchResult;
  practice: Practice;
  practiceRankList: PracticeRankListsSearchResult;
  practices: PracticesSearchResult;
  publicFile: PublicFile;
  quizExam: QuizExam;
  quizExams: QuizExamsSearchResult;
  quizQuest: QuizQuest;
  quizQuests: QuizQuestsSearchResult;
  rootDirectory: Directory;
  sectionItem: SectionItemUnion;
  sectionItems: SectionItemsSearchResult;
  tags: TagsSearchResult;
  topicTopicSections: TopicTopicSectionsSearchResult;
  user: User;
  users: UsersSearchResult;
};

export type QueryCategoriesArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryCodingExamArgs = {
  id: Scalars['ID'];
};

export type QueryCodingExamsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryCourseArgs = {
  id: Scalars['ID'];
};

export type QueryCourseCertificatesArgs = {
  courseSlug: Scalars['String'];
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryCourseLessonArgs = {
  id: Scalars['ID'];
};

export type QueryCourseLessonsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryCoursesArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryDirectoryArgs = {
  id: Scalars['ID'];
};

export type QueryFaqArgs = {
  id: Scalars['ID'];
};

export type QueryFaqAnswerArgs = {
  id: Scalars['ID'];
};

export type QueryFaqsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryGapFillExamArgs = {
  id: Scalars['ID'];
};

export type QueryGapFillExamsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryJobQuizQuestionArgs = {
  id: Scalars['ID'];
};

export type QueryJobQuizQuestionsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryLearningPathArgs = {
  id: Scalars['ID'];
};

export type QueryLearningPathsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryOrganizedExamArgs = {
  id: Scalars['ID'];
};

export type QueryOrganizedExamsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryOwnedCertificatesArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryOwnedFavoriteCoursesArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryPersonalitiesArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryPersonalityArgs = {
  id: Scalars['ID'];
};

export type QueryPostArgs = {
  id: Scalars['ID'];
};

export type QueryPostsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryPracticeArgs = {
  id: Scalars['ID'];
};

export type QueryPracticeRankListArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryPracticesArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryPublicFileArgs = {
  id: Scalars['ID'];
};

export type QueryQuizExamArgs = {
  id: Scalars['ID'];
};

export type QueryQuizExamsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryQuizQuestArgs = {
  id: Scalars['ID'];
};

export type QueryQuizQuestsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QuerySectionItemArgs = {
  id: Scalars['ID'];
};

export type QuerySectionItemsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryTagsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QueryTopicTopicSectionsArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
  topicId: Scalars['ID'];
};

export type QueryUserArgs = {
  id: Scalars['ID'];
};

export type QueryUsersArgs = {
  fields?: InputMaybe<Array<Scalars['JSON']>>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
  search?: InputMaybe<Scalars['String']>;
};

export type QuizExam = SectionItemInterface & {
  __typename?: 'QuizExam';
  createdAt: Scalars['ISO8601DateTime'];
  /** Mô tả */
  description?: Maybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: Maybe<DifficultyEnum>;
  id: Scalars['ID'];
  /** Đã hoàn thành */
  isCompleted: Scalars['Boolean'];
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  owner?: Maybe<User>;
  quizQuestBridges: Array<QuizQuestBridge>;
  slug?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  title: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type QuizExamSubmission = ExamSubmissionInterface & {
  __typename?: 'QuizExamSubmission';
  correctRatio?: Maybe<Scalars['Float']>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  judgedResult: Array<QuizQuestJudgedResult>;
  owner: User;
  stat?: Maybe<ExamSubmissionStat>;
  totalPoints?: Maybe<Scalars['Float']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type QuizExamSubmissionInput = {
  answer: Array<QuizQuestAnswerInput>;
  programId: Scalars['ID'];
  quizExamId: Scalars['ID'];
};

export type QuizExamsSearchResult = {
  __typename?: 'QuizExamsSearchResult';
  node: Array<QuizExam>;
  pageInfo: Result;
};

export type QuizQuest = ActiveRecordInterface & {
  __typename?: 'QuizQuest';
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  isSingleChoice: Scalars['Boolean'];
  name?: Maybe<Scalars['String']>;
  options?: Maybe<Array<QuizQuestOption>>;
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type QuizQuestAnswerInput = {
  checkedOptionIds: Array<Scalars['ID']>;
  quizQuestId: Scalars['ID'];
};

export type QuizQuestBridge = ActiveRecordInterface & {
  __typename?: 'QuizQuestBridge';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  quizQuest: QuizQuest;
  rowOrder?: Maybe<Scalars['Int']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type QuizQuestInput = {
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  options: Array<QuizQuestOptionInput>;
  title: Scalars['String'];
};

export type QuizQuestJudgedResult = {
  __typename?: 'QuizQuestJudgedResult';
  checkedOptionIds?: Maybe<Array<Scalars['ID']>>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  quizQuestId: Scalars['ID'];
};

export type QuizQuestOption = {
  __typename?: 'QuizQuestOption';
  content: Scalars['String'];
  id: Scalars['ID'];
  isChecked: Scalars['Boolean'];
};

export type QuizQuestOptionInput = {
  content: Scalars['String'];
  /** Id of option (prefer uuid v4) */
  id: Scalars['ID'];
  isChecked: Scalars['Boolean'];
};

export type QuizQuestsSearchResult = {
  __typename?: 'QuizQuestsSearchResult';
  node: Array<QuizQuest>;
  pageInfo: Result;
};

export type RelatedBridge = ActiveRecordInterface & {
  __typename?: 'RelatedBridge';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  rowOrder?: Maybe<Scalars['Int']>;
  to: RelatedBridgeItemUnion;
  toId: Scalars['ID'];
  toType: RelatedBridgeTypeEnum;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** Related Bridge Item Union */
export type RelatedBridgeItemUnion = Post;

export enum RelatedBridgeTypeEnum {
  Post = 'POST'
}

/** Autogenerated input type of RemoveCoursesFromFavoriteMutation */
export type RemoveCoursesFromFavoriteMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  courseIds: Array<Scalars['ID']>;
};

/** Autogenerated return type of RemoveCoursesFromFavoriteMutation */
export type RemoveCoursesFromFavoriteMutationPayload = {
  __typename?: 'RemoveCoursesFromFavoriteMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

export type ResetPasswordInput = {
  newPassword: Scalars['String'];
  token: Scalars['String'];
};

/** Autogenerated input type of ResetPasswordMutation */
export type ResetPasswordMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: ResetPasswordInput;
};

/** Autogenerated return type of ResetPasswordMutation */
export type ResetPasswordMutationPayload = {
  __typename?: 'ResetPasswordMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  /** ok or error */
  status?: Maybe<Scalars['String']>;
};

export type Result = {
  __typename?: 'Result';
  currentPage: Scalars['Int'];
  isFirstPage: Scalars['Boolean'];
  isLastPage: Scalars['Boolean'];
  isOutOfRange: Scalars['Boolean'];
  limitValue: Scalars['Int'];
  totalCount: Scalars['Int'];
  totalPages: Scalars['Int'];
};

export type SampleCode = ActiveRecordInterface & {
  __typename?: 'SampleCode';
  code: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  language: Language;
  languageId: Scalars['Int'];
  topicSectionId: Scalars['Int'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type SectionItemInterface = {
  createdAt: Scalars['ISO8601DateTime'];
  /** Độ khó */
  difficulty?: Maybe<DifficultyEnum>;
  id: Scalars['ID'];
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  owner?: Maybe<User>;
  slug?: Maybe<Scalars['String']>;
  tagList?: Maybe<Array<Scalars['String']>>;
  title: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** Section Item Union */
export type SectionItemUnion = CodingExam | CourseLesson | GapFillExam | OrganizedExam | QuizExam;

export type SectionItemsSearchResult = {
  __typename?: 'SectionItemsSearchResult';
  node: Array<SectionItemUnion>;
  pageInfo: Result;
};

/** Autogenerated input type of SendConfirmationEmailMutation */
export type SendConfirmationEmailMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
};

/** Autogenerated return type of SendConfirmationEmailMutation */
export type SendConfirmationEmailMutationPayload = {
  __typename?: 'SendConfirmationEmailMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  /** :ok or :error */
  status?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of SendResetPasswordEmailMutation */
export type SendResetPasswordEmailMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
};

/** Autogenerated return type of SendResetPasswordEmailMutation */
export type SendResetPasswordEmailMutationPayload = {
  __typename?: 'SendResetPasswordEmailMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ok or error */
  status?: Maybe<Scalars['String']>;
};

export type SignUpInput = {
  email: Scalars['String'];
  name: Scalars['String'];
  password: Scalars['String'];
  referralCode?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of SignUpMutation */
export type SignUpMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: SignUpInput;
};

/** Autogenerated return type of SignUpMutation */
export type SignUpMutationPayload = {
  __typename?: 'SignUpMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  user: User;
};

export enum StorageTypeEnum {
  Cache = 'cache',
  Store = 'store'
}

export enum SubmissionErrorTypeEnum {
  CompileError = 'COMPILE_ERROR',
  InitSandboxError = 'INIT_SANDBOX_ERROR'
}

export type Subscription = {
  __typename?: 'Subscription';
  codingExamSubmissionJudged: CodingExamSubmission;
  /** Hello Subscription */
  hello?: Maybe<Scalars['String']>;
};

export type SubscriptionCodingExamSubmissionJudgedArgs = {
  id: Scalars['ID'];
};

export type Tag = ActiveRecordInterface & {
  __typename?: 'Tag';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  taggingsCount?: Maybe<Scalars['Int']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type TagsSearchResult = {
  __typename?: 'TagsSearchResult';
  node: Array<Tag>;
  pageInfo: Result;
};

export type Topic = ActiveRecordInterface & {
  __typename?: 'Topic';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  isDraft?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  rowOrder?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  topicSections: Array<TopicSection>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type TopicSection = ActiveRecordInterface & {
  __typename?: 'TopicSection';
  codeSuggestions: Array<CodeSuggestion>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  ownedCodeSuggestionRequests?: Maybe<Array<CodeSuggestionRequest>>;
  ownedExamSubmissions?: Maybe<Array<ExamSubmissionUnion>>;
  rowOrder?: Maybe<Scalars['Int']>;
  sampleCodes: Array<SampleCode>;
  sectionItem: SectionItemUnion;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type TopicSectionView = ActiveRecordInterface & {
  __typename?: 'TopicSectionView';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  topicSectionId: Scalars['ID'];
  updatedAt: Scalars['ISO8601DateTime'];
  userId: Scalars['ID'];
};

export type TopicSectionViewInput = {
  courseId: Scalars['ID'];
  sectionItemId: Scalars['ID'];
};

export type TopicTopicSectionsSearchResult = {
  __typename?: 'TopicTopicSectionsSearchResult';
  node: Array<TopicSection>;
  pageInfo: Result;
};

/** Autogenerated input type of UpdateCategoryMutation */
export type UpdateCategoryMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: CategoryInput;
};

/** Autogenerated return type of UpdateCategoryMutation */
export type UpdateCategoryMutationPayload = {
  __typename?: 'UpdateCategoryMutationPayload';
  category: Category;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

export type UpdateCodeSuggestionInput = {
  content: Scalars['String'];
  /** Phần trăm điểm bị trừ */
  cost: Scalars['Int'];
  /** Bỏ trống để tạo mới */
  id?: InputMaybe<Scalars['ID']>;
  languageId?: InputMaybe<Scalars['Int']>;
  /** Set = true để xóa */
  willDestroy?: InputMaybe<Scalars['Boolean']>;
};

export type UpdateCodingExamInput = {
  /** Mô tả */
  description?: InputMaybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: InputMaybe<DifficultyEnum>;
  limit?: InputMaybe<CodingExamLimitInput>;
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Id của file test case (PublicFile id) */
  testCasesFileId: Scalars['ID'];
  title: Scalars['String'];
};

/** Autogenerated input type of UpdateCodingExamMutation */
export type UpdateCodingExamMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdateCodingExamInput;
};

/** Autogenerated return type of UpdateCodingExamMutation */
export type UpdateCodingExamMutationPayload = {
  __typename?: 'UpdateCodingExamMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  codingExam: CodingExam;
};

export type UpdateCommentInput = {
  content: Scalars['String'];
  contentHtml: Scalars['String'];
};

/** Autogenerated input type of UpdateCommentMutation */
export type UpdateCommentMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdateCommentInput;
};

/** Autogenerated return type of UpdateCommentMutation */
export type UpdateCommentMutationPayload = {
  __typename?: 'UpdateCommentMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  comment: Comment;
};

export type UpdateCourseInput = {
  categoryIds: Array<Scalars['ID']>;
  /** Ảnh khóa học */
  coverId?: InputMaybe<Scalars['ID']>;
  /** Mô tả khóa học */
  description: Scalars['String'];
  /** Độ khó của khóa học */
  difficulty?: InputMaybe<DifficultyEnum>;
  /** Thời lượng khóa học (giờ) */
  duration?: InputMaybe<Scalars['Int']>;
  haveCertificate?: InputMaybe<Scalars['Boolean']>;
  isDraft?: InputMaybe<Scalars['Boolean']>;
  /** Đánh dấu khóa học nổi bật */
  isFeatured?: InputMaybe<Scalars['Boolean']>;
  /** Đánh dấu khóa học thịnh hành */
  isTrending?: InputMaybe<Scalars['Boolean']>;
  /** Ngôn ngữ */
  languageIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Meta */
  meta?: InputMaybe<Scalars['JSON']>;
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Tiêu đề khóa học */
  title: Scalars['String'];
  /** Topics của khóa học */
  topicsAttributes?: InputMaybe<Array<UpdateTopicInput>>;
};

/** Autogenerated input type of UpdateCourseLessonMutation */
export type UpdateCourseLessonMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: CourseLessonInput;
};

/** Autogenerated return type of UpdateCourseLessonMutation */
export type UpdateCourseLessonMutationPayload = {
  __typename?: 'UpdateCourseLessonMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  courseLesson: CourseLesson;
};

/** Autogenerated input type of UpdateCourseMutation */
export type UpdateCourseMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdateCourseInput;
};

/** Autogenerated return type of UpdateCourseMutation */
export type UpdateCourseMutationPayload = {
  __typename?: 'UpdateCourseMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  course: Course;
};

/** Autogenerated input type of UpdateDirectoryMutation */
export type UpdateDirectoryMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: DirectoryInput;
};

/** Autogenerated return type of UpdateDirectoryMutation */
export type UpdateDirectoryMutationPayload = {
  __typename?: 'UpdateDirectoryMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  directory: Directory;
};

/** Autogenerated input type of UpdateEducationMutation */
export type UpdateEducationMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: EducationInput;
};

/** Autogenerated return type of UpdateEducationMutation */
export type UpdateEducationMutationPayload = {
  __typename?: 'UpdateEducationMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  education: Education;
};

/** Autogenerated input type of UpdateFaqAnswerMutation */
export type UpdateFaqAnswerMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: FaqAnswerInput;
};

/** Autogenerated return type of UpdateFaqAnswerMutation */
export type UpdateFaqAnswerMutationPayload = {
  __typename?: 'UpdateFaqAnswerMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  faqAnswer: FaqAnswer;
};

/** Autogenerated input type of UpdateFaqMutation */
export type UpdateFaqMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: FaqInput;
};

/** Autogenerated return type of UpdateFaqMutation */
export type UpdateFaqMutationPayload = {
  __typename?: 'UpdateFaqMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  faq: Faq;
};

export type UpdateGapFillExamInput = {
  content: Scalars['String'];
  /** Mô tả */
  description?: InputMaybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: InputMaybe<DifficultyEnum>;
  gapValues: Array<Scalars['String']>;
  isIgnoreCase?: InputMaybe<Scalars['Boolean']>;
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  title: Scalars['String'];
};

/** Autogenerated input type of UpdateGapFillExamMutation */
export type UpdateGapFillExamMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdateGapFillExamInput;
};

/** Autogenerated return type of UpdateGapFillExamMutation */
export type UpdateGapFillExamMutationPayload = {
  __typename?: 'UpdateGapFillExamMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  gapFillExam: GapFillExam;
};

/** Autogenerated input type of UpdateJobQuizQuestionsMutation */
export type UpdateJobQuizQuestionsMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: Array<JobQuizQuestionInput>;
};

/** Autogenerated return type of UpdateJobQuizQuestionsMutation */
export type UpdateJobQuizQuestionsMutationPayload = {
  __typename?: 'UpdateJobQuizQuestionsMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  jobQuizQuestions: Array<JobQuizQuestion>;
};

export type UpdateLearningPathInput = {
  /** Lợi ích sau khi học khóa học */
  benefits: Scalars['JSON'];
  /** Học đầy đủ khóa học mang lại */
  benefitsSummary: Scalars['JSON'];
  /** Ảnh */
  coverId?: InputMaybe<Scalars['ID']>;
  /** Mô tả */
  description: Scalars['String'];
  /** Độ khó của khóa học */
  difficulty?: InputMaybe<DifficultyEnum>;
  /** Thời lượng */
  duration: Scalars['Int'];
  /** Khóa học bao gồm */
  includes: Scalars['String'];
  learningPathsProgramsAttributes?: InputMaybe<Array<UpdateLearningPathsProgramInput>>;
  /** Meta */
  meta?: InputMaybe<Scalars['JSON']>;
  /** Các dự án bạn sẽ xây dựng */
  projects: Scalars['JSON'];
  slug?: InputMaybe<Scalars['String']>;
  /** Tổng quan */
  summary: Scalars['String'];
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Khóa học dành cho  */
  target: Scalars['String'];
  /** Tiêu đề */
  title: Scalars['String'];
};

/** Autogenerated input type of UpdateLearningPathMutation */
export type UpdateLearningPathMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdateLearningPathInput;
};

/** Autogenerated return type of UpdateLearningPathMutation */
export type UpdateLearningPathMutationPayload = {
  __typename?: 'UpdateLearningPathMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  learningPath: LearningPath;
};

export type UpdateLearningPathsProgramInput = {
  /** Bỏ trống để tạo mới */
  id?: InputMaybe<Scalars['ID']>;
  programId: Scalars['ID'];
  rowOrderPosition: Scalars['Int'];
  /** Set = true để xóa */
  willDestroy?: InputMaybe<Scalars['Boolean']>;
};

export type UpdateOrganizedExamInput = {
  allowList: Array<Scalars['String']>;
  canRunCode?: InputMaybe<Scalars['Boolean']>;
  content: Scalars['String'];
  denyList: Array<Scalars['String']>;
  /** Mô tả */
  description?: InputMaybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: InputMaybe<DifficultyEnum>;
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  title: Scalars['String'];
};

/** Autogenerated input type of UpdateOrganizedExamMutation */
export type UpdateOrganizedExamMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdateOrganizedExamInput;
};

/** Autogenerated return type of UpdateOrganizedExamMutation */
export type UpdateOrganizedExamMutationPayload = {
  __typename?: 'UpdateOrganizedExamMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  organizedExam: OrganizedExam;
};

/** Autogenerated input type of UpdatePersonalityMutation */
export type UpdatePersonalityMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: PersonalityInput;
};

/** Autogenerated return type of UpdatePersonalityMutation */
export type UpdatePersonalityMutationPayload = {
  __typename?: 'UpdatePersonalityMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  personality: Personality;
};

export type UpdatePostInput = {
  categoryIds: Array<Scalars['ID']>;
  /** Nội dung bài viết */
  content: Scalars['String'];
  /** Meta */
  meta?: InputMaybe<Scalars['JSON']>;
  /** bài viết liên quan */
  relatedBridgesAttributes?: InputMaybe<Array<UpdateRelatedBridgeInput>>;
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Ảnh xem trước của bài viết */
  thumbnailId?: InputMaybe<Scalars['ID']>;
  /** Tiêu đề bài viết */
  title: Scalars['String'];
};

/** Autogenerated input type of UpdatePostMutation */
export type UpdatePostMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdatePostInput;
};

/** Autogenerated return type of UpdatePostMutation */
export type UpdatePostMutationPayload = {
  __typename?: 'UpdatePostMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  post: Post;
};

export type UpdatePracticeInput = {
  categoryIds: Array<Scalars['ID']>;
  /** Ảnh khóa học */
  coverId?: InputMaybe<Scalars['ID']>;
  /** Mô tả khóa học */
  description: Scalars['String'];
  /** Độ khó của khóa học */
  difficulty?: InputMaybe<DifficultyEnum>;
  /** Thời lượng khóa học (giờ) */
  duration?: InputMaybe<Scalars['Int']>;
  haveCertificate?: InputMaybe<Scalars['Boolean']>;
  isDraft?: InputMaybe<Scalars['Boolean']>;
  /** Đánh dấu khóa học nổi bật */
  isFeatured?: InputMaybe<Scalars['Boolean']>;
  /** Đánh dấu khóa học thịnh hành */
  isTrending?: InputMaybe<Scalars['Boolean']>;
  /** Ngôn ngữ */
  languageIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Meta */
  meta?: InputMaybe<Scalars['JSON']>;
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Tiêu đề khóa học */
  title: Scalars['String'];
  /** Topics của khóa học */
  topicsAttributes?: InputMaybe<Array<UpdateTopicInput>>;
};

/** Autogenerated input type of UpdatePracticeMutation */
export type UpdatePracticeMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdatePracticeInput;
};

/** Autogenerated return type of UpdatePracticeMutation */
export type UpdatePracticeMutationPayload = {
  __typename?: 'UpdatePracticeMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  practice: Practice;
};

export type UpdateProfileInput = {
  address?: InputMaybe<Scalars['String']>;
  avatarId?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  facebookUrl?: InputMaybe<Scalars['String']>;
  linkedinUrl?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateProfileMutation */
export type UpdateProfileMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: UpdateProfileInput;
};

/** Autogenerated return type of UpdateProfileMutation */
export type UpdateProfileMutationPayload = {
  __typename?: 'UpdateProfileMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  user: User;
};

export type UpdatePublicFileInput = {
  /** Directory Id */
  directoryId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated input type of UpdatePublicFileMutation */
export type UpdatePublicFileMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdatePublicFileInput;
};

/** Autogenerated return type of UpdatePublicFileMutation */
export type UpdatePublicFileMutationPayload = {
  __typename?: 'UpdatePublicFileMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  publicFile: PublicFile;
};

export type UpdateQuizExamInput = {
  /** Mô tả */
  description?: InputMaybe<Scalars['String']>;
  /** Độ khó */
  difficulty?: InputMaybe<DifficultyEnum>;
  /** Điểm tối đa */
  maxPoints: Scalars['Float'];
  quizQuestBridgesAttributes?: InputMaybe<Array<UpdateQuizQuestBridgeInput>>;
  slug?: InputMaybe<Scalars['String']>;
  /** Danh sách tag */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  title: Scalars['String'];
};

/** Autogenerated input type of UpdateQuizExamMutation */
export type UpdateQuizExamMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdateQuizExamInput;
};

/** Autogenerated return type of UpdateQuizExamMutation */
export type UpdateQuizExamMutationPayload = {
  __typename?: 'UpdateQuizExamMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  quizExam: QuizExam;
};

export type UpdateQuizQuestBridgeInput = {
  /** Bỏ trống để tạo mới */
  id?: InputMaybe<Scalars['ID']>;
  quizQuestId: Scalars['ID'];
  rowOrderPosition: Scalars['Int'];
  /** Set = true để xóa */
  willDestroy?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated input type of UpdateQuizQuestMutation */
export type UpdateQuizQuestMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: QuizQuestInput;
};

/** Autogenerated return type of UpdateQuizQuestMutation */
export type UpdateQuizQuestMutationPayload = {
  __typename?: 'UpdateQuizQuestMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  quizQuest: QuizQuest;
};

export type UpdateRelatedBridgeInput = {
  /** Bỏ trống để tạo mới */
  id?: InputMaybe<Scalars['ID']>;
  rowOrderPosition: Scalars['Int'];
  toId: Scalars['ID'];
  toType: RelatedBridgeTypeEnum;
  /** Set = true để xóa */
  willDestroy?: InputMaybe<Scalars['Boolean']>;
};

export type UpdateSampleCodeInput = {
  code: Scalars['String'];
  /** Bỏ trống để tạo mới */
  id?: InputMaybe<Scalars['ID']>;
  languageId: Scalars['Int'];
  /** Set = true để xóa */
  willDestroy?: InputMaybe<Scalars['Boolean']>;
};

export type UpdateTopicInput = {
  /** Bỏ trống để tạo mới */
  id?: InputMaybe<Scalars['ID']>;
  isDraft?: InputMaybe<Scalars['Boolean']>;
  /** Tên topic */
  name: Scalars['String'];
  /** Thứ tự của topic */
  rowOrderPosition: Scalars['Int'];
  /** Tổng quan topic */
  summary?: InputMaybe<Scalars['String']>;
  /** Danh sách section của topics */
  topicSectionsAttributes?: InputMaybe<Array<UpdateTopicSectionInput>>;
  /** Set = true để xóa */
  willDestroy?: InputMaybe<Scalars['Boolean']>;
};

export type UpdateTopicSectionInput = {
  codeSuggestionsAttributes?: InputMaybe<Array<UpdateCodeSuggestionInput>>;
  /** Bỏ trống để tạo mới */
  id?: InputMaybe<Scalars['ID']>;
  rowOrderPosition: Scalars['Int'];
  sampleCodesAttributes?: InputMaybe<Array<UpdateSampleCodeInput>>;
  sectionItemId: Scalars['ID'];
  /** Set = true để xóa */
  willDestroy?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated input type of UpdateUserMutation */
export type UpdateUserMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UserInput;
};

/** Autogenerated return type of UpdateUserMutation */
export type UpdateUserMutationPayload = {
  __typename?: 'UpdateUserMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  user: User;
};

export type UpdateUserRoleInput = {
  role: UserRoleEnum;
};

/** Autogenerated input type of UpdateUserRoleMutation */
export type UpdateUserRoleMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: UpdateUserRoleInput;
};

/** Autogenerated return type of UpdateUserRoleMutation */
export type UpdateUserRoleMutationPayload = {
  __typename?: 'UpdateUserRoleMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  user: User;
};

/** Autogenerated input type of UpdateWorkExperienceMutation */
export type UpdateWorkExperienceMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  params: WorkExperienceInput;
};

/** Autogenerated return type of UpdateWorkExperienceMutation */
export type UpdateWorkExperienceMutationPayload = {
  __typename?: 'UpdateWorkExperienceMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  workExperience: WorkExperience;
};

export type User = ActiveRecordInterface & {
  __typename?: 'User';
  address?: Maybe<Scalars['String']>;
  avatar?: Maybe<PublicFile>;
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  donePracticesCount: Scalars['Int'];
  educations: Array<Education>;
  email?: Maybe<Scalars['String']>;
  facebookUrl?: Maybe<Scalars['String']>;
  faqVotes: Scalars['Int'];
  gold: Scalars['Int'];
  id: Scalars['ID'];
  linkedinUrl?: Maybe<Scalars['String']>;
  monthPoints: Scalars['Float'];
  name?: Maybe<Scalars['String']>;
  practicePoints: Scalars['Float'];
  practiceRank: Scalars['Int'];
  referralCode: Scalars['String'];
  referredUsersCount: Scalars['Int'];
  referrer?: Maybe<User>;
  role: UserRoleEnum;
  updatedAt: Scalars['ISO8601DateTime'];
  weekPoints: Scalars['Float'];
  workExperiences: Array<WorkExperience>;
  yearPoints: Scalars['Float'];
};

export type UserCertificate = ActiveRecordInterface & {
  __typename?: 'UserCertificate';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  programsUser: ProgramsUser;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type UserInput = {
  email: Scalars['String'];
  name: Scalars['String'];
  password?: InputMaybe<Scalars['String']>;
  role: UserRoleEnum;
};

export enum UserRoleEnum {
  Admin = 'ADMIN',
  Editor = 'EDITOR',
  Moderator = 'MODERATOR',
  User = 'USER'
}

export type UsersSearchResult = {
  __typename?: 'UsersSearchResult';
  node: Array<User>;
  pageInfo: Result;
};

/** Autogenerated input type of ViewTopicSectionMutation */
export type ViewTopicSectionMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: TopicSectionViewInput;
};

/** Autogenerated return type of ViewTopicSectionMutation */
export type ViewTopicSectionMutationPayload = {
  __typename?: 'ViewTopicSectionMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  topicSectionView: TopicSectionView;
};

export type Vote = {
  __typename?: 'Vote';
  count?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of VoteCommentMutation */
export type VoteCommentMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateVoteInput;
};

/** Autogenerated return type of VoteCommentMutation */
export type VoteCommentMutationPayload = {
  __typename?: 'VoteCommentMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  vote: Vote;
};

/** Autogenerated input type of VoteFaqAnswerMutation */
export type VoteFaqAnswerMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateVoteInput;
};

/** Autogenerated return type of VoteFaqAnswerMutation */
export type VoteFaqAnswerMutationPayload = {
  __typename?: 'VoteFaqAnswerMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  vote: Vote;
};

/** Autogenerated input type of VoteFaqMutation */
export type VoteFaqMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateVoteInput;
};

/** Autogenerated return type of VoteFaqMutation */
export type VoteFaqMutationPayload = {
  __typename?: 'VoteFaqMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  vote: Vote;
};

/** Autogenerated input type of VotePostMutation */
export type VotePostMutationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  params: CreateVoteInput;
};

/** Autogenerated return type of VotePostMutation */
export type VotePostMutationPayload = {
  __typename?: 'VotePostMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  vote: Vote;
};

export enum VoteTypeEnum {
  DownVote = 'DOWN_VOTE',
  UpVote = 'UP_VOTE'
}

export type WorkExperience = ActiveRecordInterface & {
  __typename?: 'WorkExperience';
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['ISO8601DateTime']>;
  id: Scalars['ID'];
  jobTitle: Scalars['String'];
  startDate?: Maybe<Scalars['ISO8601DateTime']>;
  updatedAt: Scalars['ISO8601DateTime'];
  workspaceName: Scalars['String'];
};

export type WorkExperienceInput = {
  description?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['ISO8601DateTime']>;
  jobTitle: Scalars['String'];
  startDate?: InputMaybe<Scalars['ISO8601DateTime']>;
  workspaceName: Scalars['String'];
};

export type MeQueryVariables = Exact<{ [key: string]: never; }>;

export type MeQuery = { __typename?: 'Query', me: { __typename?: 'User', address?: string | null | undefined, description?: string | null | undefined, email?: string | null | undefined, facebookUrl?: string | null | undefined, id: string, linkedinUrl?: string | null | undefined, name?: string | null | undefined, role: UserRoleEnum, referralCode: string, practicePoints: number, practiceRank: number, donePracticesCount: number, referredUsersCount: number, avatar?: { __typename?: 'PublicFile', thumbnailUrl: string } | null | undefined, referrer?: { __typename?: 'User', email?: string | null | undefined, id: string, name?: string | null | undefined, referralCode: string, referredUsersCount: number } | null | undefined } };

export type OwnedCoursesQueryVariables = Exact<{ [key: string]: never; }>;

export type OwnedCoursesQuery = { __typename?: 'Query', ownedCourses?: Array<{ __typename?: 'Course', id: string, title?: string | null | undefined, slug?: string | null | undefined, lessonsCount?: number | null | undefined, ownedProgress?: number | null | undefined, cover?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined, readingTopicSection?: { __typename?: 'TopicSection', id: string, sectionItem: { __typename?: 'CodingExam', slug?: string | null | undefined } | { __typename?: 'CourseLesson', slug?: string | null | undefined } | { __typename?: 'GapFillExam', slug?: string | null | undefined } | { __typename?: 'OrganizedExam', slug?: string | null | undefined } | { __typename?: 'QuizExam', slug?: string | null | undefined } } | null | undefined }> | null | undefined };

export type OwnedFavoriteCoursesQueryVariables = Exact<{
  search?: InputMaybe<Scalars['String']>;
  fields?: InputMaybe<Array<Scalars['JSON']> | Scalars['JSON']>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
}>;

export type OwnedFavoriteCoursesQuery = { __typename?: 'Query', ownedFavoriteCourses: { __typename?: 'OwnedFavoriteCoursesSearchResult', node: Array<{ __typename?: 'FavoriteCourse', courseId: string, id: string, course: { __typename?: 'Course', id: string, title?: string | null | undefined, slug?: string | null | undefined, lessonsCount?: number | null | undefined, ownedProgress?: number | null | undefined, cover?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined, readingTopicSection?: { __typename?: 'TopicSection', id: string, sectionItem: { __typename?: 'CodingExam', slug?: string | null | undefined } | { __typename?: 'CourseLesson', slug?: string | null | undefined } | { __typename?: 'GapFillExam', slug?: string | null | undefined } | { __typename?: 'OrganizedExam', slug?: string | null | undefined } | { __typename?: 'QuizExam', slug?: string | null | undefined } } | null | undefined } }>, pageInfo: { __typename?: 'Result', totalCount: number } } };

export type CoursesQueryVariables = Exact<{
  search?: InputMaybe<Scalars['String']>;
  fields?: InputMaybe<Array<Scalars['JSON']> | Scalars['JSON']>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
}>;

export type CoursesQuery = { __typename?: 'Query', courses: { __typename?: 'CoursesSearchResult', node: Array<{ __typename?: 'Course', id: string, title?: string | null | undefined, slug?: string | null | undefined, lessonsCount?: number | null | undefined, cover?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined }>, pageInfo: { __typename?: 'Result', totalCount: number } } };

export type CourseQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type CourseQuery = { __typename?: 'Query', course: { __typename?: 'Course', difficulty?: DifficultyEnum | null | undefined, id: string, title?: string | null | undefined, tagList?: Array<string> | null | undefined, slug?: string | null | undefined, description?: string | null | undefined, duration?: number | null | undefined, isDraft?: boolean | null | undefined, isFavorite?: boolean | null | undefined, isFeatured?: boolean | null | undefined, isJoined?: boolean | null | undefined, isTrending?: boolean | null | undefined, lessonsCount?: number | null | undefined, meta?: any | null | undefined, examsCount: number, ownedProgress?: number | null | undefined, totalPoints: number, categories: Array<{ __typename?: 'Category', id: string, name: string }>, cover?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined, comments: Array<{ __typename?: 'Comment', contentHtml?: string | null | undefined, id: string, votesSum?: number | null | undefined, updatedAt: any, ownedVote?: { __typename?: 'Vote', count?: number | null | undefined } | null | undefined, votes: Array<{ __typename?: 'Vote', count?: number | null | undefined }>, user: { __typename?: 'User', name?: string | null | undefined, avatar?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined } }>, topics?: Array<{ __typename?: 'Topic', id: string, name?: string | null | undefined, summary?: string | null | undefined, topicSections: Array<{ __typename?: 'TopicSection', id: string, codeSuggestions: Array<{ __typename?: 'CodeSuggestion', id: string, languageId?: number | null | undefined, topicSectionId: number, cost: number, language?: { __typename?: 'Language', canJudge: boolean, id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined } | null | undefined }>, sampleCodes: Array<{ __typename?: 'SampleCode', id: string, languageId: number, topicSectionId: number, language: { __typename?: 'Language', canJudge: boolean, id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined } }>, sectionItem: { __typename?: 'CodingExam', description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, limit: { __typename?: 'CodingExamLimit', memoryLimit?: number | null | undefined, sourceLimit?: number | null | undefined, timeLimit?: number | null | undefined } } | { __typename?: 'CourseLesson', content: string, duration?: number | null | undefined, id: string, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, featureImage?: { __typename?: 'PublicFile', downloadUrl: string, filename: string, id: string, metadata: any, thumbnailUrl: string } | null | undefined } | { __typename?: 'GapFillExam', content: string, description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string } | { __typename?: 'OrganizedExam', canRunCode: boolean, content: string, description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string } | { __typename?: 'QuizExam', description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, quizQuestBridges: Array<{ __typename?: 'QuizQuestBridge', id: string, quizQuest: { __typename?: 'QuizQuest', description?: string | null | undefined, id: string, isSingleChoice: boolean, name?: string | null | undefined, title?: string | null | undefined, options?: Array<{ __typename?: 'QuizQuestOption', content: string, id: string }> | null | undefined } }> } }> }> | null | undefined, readingTopicSection?: { __typename?: 'TopicSection', sectionItem: { __typename?: 'CodingExam', slug?: string | null | undefined } | { __typename?: 'CourseLesson', slug?: string | null | undefined } | { __typename?: 'GapFillExam', slug?: string | null | undefined } | { __typename?: 'OrganizedExam', slug?: string | null | undefined } | { __typename?: 'QuizExam', slug?: string | null | undefined } } | null | undefined } };

export type PracticesQueryVariables = Exact<{
  search?: InputMaybe<Scalars['String']>;
  fields?: InputMaybe<Array<Scalars['JSON']> | Scalars['JSON']>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
}>;

export type PracticesQuery = { __typename?: 'Query', practices: { __typename?: 'PracticesSearchResult', node: Array<{ __typename?: 'Practice', id: string, title?: string | null | undefined, slug?: string | null | undefined, lessonsCount?: number | null | undefined, examsCount: number, ownedProgress?: number | null | undefined, totalPoints: number, cover?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined }>, pageInfo: { __typename?: 'Result', totalCount: number } } };

export type PracticeQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type PracticeQuery = { __typename?: 'Query', practice: { __typename?: 'Practice', difficulty?: DifficultyEnum | null | undefined, id: string, title?: string | null | undefined, tagList?: Array<string> | null | undefined, slug?: string | null | undefined, description?: string | null | undefined, duration?: number | null | undefined, isDraft?: boolean | null | undefined, isFeatured?: boolean | null | undefined, isJoined?: boolean | null | undefined, isTrending?: boolean | null | undefined, lessonsCount?: number | null | undefined, meta?: any | null | undefined, examsCount: number, ownedProgress?: number | null | undefined, totalPoints: number, categories: Array<{ __typename?: 'Category', id: string, name: string }>, cover?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined, comments: Array<{ __typename?: 'Comment', contentHtml?: string | null | undefined, id: string, votesSum?: number | null | undefined, updatedAt: any, ownedVote?: { __typename?: 'Vote', count?: number | null | undefined } | null | undefined, votes: Array<{ __typename?: 'Vote', count?: number | null | undefined }>, user: { __typename?: 'User', name?: string | null | undefined, avatar?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined } }>, topics?: Array<{ __typename?: 'Topic', id: string }> | null | undefined, languages: Array<{ __typename?: 'Language', canJudge: boolean, id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined }> } };

export type PracticeRankListQueryVariables = Exact<{
  search?: InputMaybe<Scalars['String']>;
  fields?: InputMaybe<Array<Scalars['JSON']> | Scalars['JSON']>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
}>;

export type PracticeRankListQuery = { __typename?: 'Query', practiceRankList: { __typename?: 'PracticeRankListsSearchResult', node: Array<{ __typename?: 'User', id: string, name?: string | null | undefined, practicePoints: number, avatar?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined }>, pageInfo: { __typename?: 'Result', totalCount: number } } };

export type JoinProgramMutationVariables = Exact<{
  input: JoinProgramMutationInput;
}>;

export type JoinProgramMutation = { __typename?: 'Mutation', joinProgram?: { __typename?: 'JoinProgramMutationPayload', programsUser: { __typename?: 'ProgramsUser', id: string, programId: string, userId: string } } | null | undefined };

export type ViewTopicSectionMutationVariables = Exact<{
  input: ViewTopicSectionMutationInput;
}>;

export type ViewTopicSectionMutation = { __typename?: 'Mutation', viewTopicSection?: { __typename?: 'ViewTopicSectionMutationPayload', topicSectionView: { __typename?: 'TopicSectionView', id: string, topicSectionId: string, userId: string } } | null | undefined };

export type CreateCommentMutationVariables = Exact<{
  input: CreateCommentMutationInput;
}>;

export type CreateCommentMutation = { __typename?: 'Mutation', createComment?: { __typename?: 'CreateCommentMutationPayload', comment: { __typename?: 'Comment', id: string } } | null | undefined };

export type RemoveCoursesFromFavoriteMutationVariables = Exact<{
  input: RemoveCoursesFromFavoriteMutationInput;
}>;

export type RemoveCoursesFromFavoriteMutation = { __typename?: 'Mutation', removeCoursesFromFavorite?: { __typename?: 'RemoveCoursesFromFavoriteMutationPayload', status?: string | null | undefined } | null | undefined };

export type CreateFavoriteCourseMutationVariables = Exact<{
  input: CreateFavoriteCourseMutationInput;
}>;

export type CreateFavoriteCourseMutation = { __typename?: 'Mutation', createFavoriteCourse?: { __typename?: 'CreateFavoriteCourseMutationPayload', favoriteCourse: { __typename?: 'FavoriteCourse', id: string } } | null | undefined };

export type CreateCodeSuggestionRequestMutationVariables = Exact<{
  input: CreateCodeSuggestionRequestMutationInput;
}>;

export type CreateCodeSuggestionRequestMutation = { __typename?: 'Mutation', createCodeSuggestionRequest?: { __typename?: 'CreateCodeSuggestionRequestMutationPayload', codeSuggestionRequest: { __typename?: 'CodeSuggestionRequest', codeSuggestionId: string, content: string, cost: number, id: string } } | null | undefined };

export type CourseLessonQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type CourseLessonQuery = { __typename?: 'Query', courseLesson: { __typename?: 'CourseLesson', content: string, duration?: number | null | undefined, id: string, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, featureImage?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined } };

export type QuizExamQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type QuizExamQuery = { __typename?: 'Query', quizExam: { __typename?: 'QuizExam', description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, quizQuestBridges: Array<{ __typename?: 'QuizQuestBridge', id: string, rowOrder?: number | null | undefined, quizQuest: { __typename?: 'QuizQuest', id: string, description?: string | null | undefined, isSingleChoice: boolean, name?: string | null | undefined, title?: string | null | undefined, options?: Array<{ __typename?: 'QuizQuestOption', id: string, content: string, isChecked: boolean }> | null | undefined } }> } };

export type QuizQuestQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type QuizQuestQuery = { __typename?: 'Query', quizQuest: { __typename?: 'QuizQuest', description?: string | null | undefined, id: string, isSingleChoice: boolean, name?: string | null | undefined, title?: string | null | undefined, options?: Array<{ __typename?: 'QuizQuestOption', content: string, id: string, isChecked: boolean }> | null | undefined } };

export type CreateQuizExamSubmissionMutationVariables = Exact<{
  input: CreateQuizExamSubmissionMutationInput;
}>;

export type CreateQuizExamSubmissionMutation = { __typename?: 'Mutation', createQuizExamSubmission?: { __typename?: 'CreateQuizExamSubmissionMutationPayload', quizExamSubmission: { __typename?: 'QuizExamSubmission', id: string, correctRatio?: number | null | undefined, totalPoints?: number | null | undefined, judgedResult: Array<{ __typename?: 'QuizQuestJudgedResult', checkedOptionIds?: Array<string> | null | undefined, isCorrect?: boolean | null | undefined, quizQuestId: string }>, stat?: { __typename?: 'ExamSubmissionStat', correctCount: number, totalCount: number } | null | undefined } } | null | undefined };

export type GapFillExamQueryVariables = Exact<{
  id: Scalars['ID'];
  programId: Scalars['ID'];
}>;

export type GapFillExamQuery = { __typename?: 'Query', gapFillExam: { __typename?: 'GapFillExam', content: string, description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, gapValues: Array<string>, id: string, isIgnoreCase: boolean, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, topicSection?: { __typename?: 'TopicSection', codeSuggestions: Array<{ __typename?: 'CodeSuggestion', id: string, cost: number }> } | null | undefined } };

export type CreateGapFillExamSubmissionMutationVariables = Exact<{
  input: CreateGapFillExamSubmissionMutationInput;
}>;

export type CreateGapFillExamSubmissionMutation = { __typename?: 'Mutation', createGapFillExamSubmission?: { __typename?: 'CreateGapFillExamSubmissionMutationPayload', gapFillExamSubmission: { __typename?: 'GapFillExamSubmission', id: string, correctRatio?: number | null | undefined, filledValues?: Array<string> | null | undefined, totalPoints?: number | null | undefined, judgedResult?: Array<{ __typename?: 'GapFillExamJudgedResult', index: number, isCorrect: boolean }> | null | undefined, stat?: { __typename?: 'ExamSubmissionStat', correctCount: number, totalCount: number } | null | undefined } } | null | undefined };

export type CodingExamQueryVariables = Exact<{
  id: Scalars['ID'];
  programId: Scalars['ID'];
}>;

export type CodingExamQuery = { __typename?: 'Query', codingExam: { __typename?: 'CodingExam', description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, limit: { __typename?: 'CodingExamLimit', memoryLimit?: number | null | undefined, timeLimit?: number | null | undefined, sourceLimit?: number | null | undefined }, testCases: Array<{ __typename?: 'CodingExamTestCase', input: string, output: string }>, testCasesFile: { __typename?: 'PublicFile', id: string, metadata: any, filename: string }, topicSection?: { __typename?: 'TopicSection', codeSuggestions: Array<{ __typename?: 'CodeSuggestion', cost: number, id: string, languageId?: number | null | undefined, topicSectionId: number, language?: { __typename?: 'Language', canJudge: boolean, id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined } | null | undefined }>, sampleCodes: Array<{ __typename?: 'SampleCode', id: string, languageId: number, topicSectionId: number, code: string, language: { __typename?: 'Language', canJudge: boolean, id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined } }> } | null | undefined } };

export type CreateCodingExamSubmissionMutationVariables = Exact<{
  input: CreateCodingExamSubmissionMutationInput;
}>;

export type CreateCodingExamSubmissionMutation = { __typename?: 'Mutation', createCodingExamSubmission?: { __typename?: 'CreateCodingExamSubmissionMutationPayload', codingExamSubmission: { __typename?: 'CodingExamSubmission', caseResults?: any | null | undefined, correctRatio?: number | null | undefined, id: string, isJudged: boolean, src: string, totalPoints?: number | null | undefined, error?: { __typename?: 'CodingExamSubmissionError', message?: string | null | undefined, type?: SubmissionErrorTypeEnum | null | undefined } | null | undefined, language: { __typename?: 'Language', canJudge: boolean, id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined }, stat?: { __typename?: 'ExamSubmissionStat', correctCount: number, totalCount: number } | null | undefined } } | null | undefined };

export type CodingExamSubmissionJudgedSubscriptionVariables = Exact<{
  id: Scalars['ID'];
}>;

export type CodingExamSubmissionJudgedSubscription = { __typename?: 'Subscription', codingExamSubmissionJudged: { __typename?: 'CodingExamSubmission', caseResults?: any | null | undefined, correctRatio?: number | null | undefined, id: string, isJudged: boolean, src: string, totalPoints?: number | null | undefined, error?: { __typename?: 'CodingExamSubmissionError', message?: string | null | undefined, type?: SubmissionErrorTypeEnum | null | undefined } | null | undefined, language: { __typename?: 'Language', canJudge: boolean, createdAt: any, id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined }, stat?: { __typename?: 'ExamSubmissionStat', correctCount: number, totalCount: number } | null | undefined } };

export type OrganizedExamQueryVariables = Exact<{
  id: Scalars['ID'];
  programId: Scalars['ID'];
}>;

export type OrganizedExamQuery = { __typename?: 'Query', organizedExam: { __typename?: 'OrganizedExam', allowList: Array<string>, canRunCode: boolean, content: string, maxPoints: number, id: string, difficulty?: DifficultyEnum | null | undefined, description?: string | null | undefined, denyList: Array<string>, title: string, tagList?: Array<string> | null | undefined, slug?: string | null | undefined, topicSection?: { __typename?: 'TopicSection', codeSuggestions: Array<{ __typename?: 'CodeSuggestion', cost: number, id: string, languageId?: number | null | undefined, topicSectionId: number, language?: { __typename?: 'Language', canJudge: boolean, id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined } | null | undefined }>, sampleCodes: Array<{ __typename?: 'SampleCode', id: string, languageId: number, topicSectionId: number, code: string, language: { __typename?: 'Language', canJudge: boolean, id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined } }> } | null | undefined } };

export type CreateOrganizedExamSubmissionMutationVariables = Exact<{
  input: CreateOrganizedExamSubmissionMutationInput;
}>;

export type CreateOrganizedExamSubmissionMutation = { __typename?: 'Mutation', createOrganizedExamSubmission?: { __typename?: 'CreateOrganizedExamSubmissionMutationPayload', organizedExamSubmission: { __typename?: 'OrganizedExamSubmission', content: string, correctRatio?: number | null | undefined, id: string, totalPoints?: number | null | undefined, mistake?: { __typename?: 'OrganizedExamMistake', missingKeyword?: string | null | undefined, prohibitKeywords: Array<string> } | null | undefined, stat?: { __typename?: 'ExamSubmissionStat', correctCount: number, totalCount: number } | null | undefined } } | null | undefined };

export type JdoodleExecuteMutationVariables = Exact<{
  input: JdoodleExecuteMutationInput;
}>;

export type JdoodleExecuteMutation = { __typename?: 'Mutation', jdoodleExecute?: { __typename?: 'JdoodleExecuteMutationPayload', response: { __typename?: 'JdoodleExecuteResponse', body: any, status: number } } | null | undefined };

export type CategoriesQueryVariables = Exact<{
  search?: InputMaybe<Scalars['String']>;
  fields?: InputMaybe<Array<Scalars['JSON']> | Scalars['JSON']>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
}>;

export type CategoriesQuery = { __typename?: 'Query', categories: { __typename?: 'CategoriesSearchResult', node: Array<{ __typename?: 'Category', id: string, name: string, slug?: string | null | undefined }> } };

export type TagsQueryVariables = Exact<{
  search?: InputMaybe<Scalars['String']>;
  fields?: InputMaybe<Array<Scalars['JSON']> | Scalars['JSON']>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
}>;

export type TagsQuery = { __typename?: 'Query', tags: { __typename?: 'TagsSearchResult', node: Array<{ __typename?: 'Tag', id: string, name: string }> } };

export type AllLanguagesQueryVariables = Exact<{ [key: string]: never; }>;

export type AllLanguagesQuery = { __typename?: 'Query', allLanguages: Array<{ __typename?: 'Language', id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined }> };

export type LearningPathsQueryVariables = Exact<{
  search?: InputMaybe<Scalars['String']>;
  fields?: InputMaybe<Array<Scalars['JSON']> | Scalars['JSON']>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
}>;

export type LearningPathsQuery = { __typename?: 'Query', learningPaths: { __typename?: 'LearningPathsSearchResult', node: Array<{ __typename?: 'LearningPath', id: string, slug: string, title: string }>, pageInfo: { __typename?: 'Result', totalCount: number } } };

export type LearningPathQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type LearningPathQuery = { __typename?: 'Query', learningPath: { __typename?: 'LearningPath', benefits?: any | null | undefined, benefitsSummary?: any | null | undefined, description?: string | null | undefined, difficulty: DifficultyEnum, duration?: number | null | undefined, id: string, includes?: string | null | undefined, isJoined: boolean, meta?: any | null | undefined, ownedProgress?: number | null | undefined, projects?: any | null | undefined, slug: string, summary?: string | null | undefined, tagList?: Array<string> | null | undefined, target?: string | null | undefined, title: string, cover?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined, learningPathsPrograms: Array<{ __typename?: 'LearningPathsProgram', id: string, program: { __typename?: 'Course', id: string, slug?: string | null | undefined, title?: string | null | undefined, description?: string | null | undefined } }>, reading?: { __typename?: 'LearningPathReading', courseSlug: string, sectionItemSlug: string } | null | undefined } };

export type JoinLearningPathMutationVariables = Exact<{
  input: JoinLearningPathMutationInput;
}>;

export type JoinLearningPathMutation = { __typename?: 'Mutation', joinLearningPath?: { __typename?: 'JoinLearningPathMutationPayload', status?: string | null | undefined } | null | undefined };

export type UsersQueryVariables = Exact<{
  search?: InputMaybe<Scalars['String']>;
  fields?: InputMaybe<Array<Scalars['JSON']> | Scalars['JSON']>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
}>;

export type UsersQuery = { __typename?: 'Query', users: { __typename?: 'UsersSearchResult', node: Array<{ __typename?: 'User', faqVotes: number, id: string, name?: string | null | undefined, practicePoints: number, donePracticesCount: number, referredUsersCount: number, avatar?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined }>, pageInfo: { __typename?: 'Result', totalCount: number } } };

export type PostsQueryVariables = Exact<{
  search?: InputMaybe<Scalars['String']>;
  fields?: InputMaybe<Array<Scalars['JSON']> | Scalars['JSON']>;
  filter?: InputMaybe<Scalars['JSON']>;
  order?: InputMaybe<Scalars['JSON']>;
  paginate?: InputMaybe<PaginateInput>;
}>;

export type PostsQuery = { __typename?: 'Query', posts: { __typename?: 'PostsSearchResult', node: Array<{ __typename?: 'Post', content: string, id: string, meta?: any | null | undefined, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, viewsCount: number, votesSum?: number | null | undefined, updatedAt: any, categories: Array<{ __typename?: 'Category', id: string, name: string }>, comments: Array<{ __typename?: 'Comment', contentHtml?: string | null | undefined, id: string, votesSum?: number | null | undefined, ownedVote?: { __typename?: 'Vote', count?: number | null | undefined } | null | undefined, user: { __typename?: 'User', id: string, name?: string | null | undefined, avatar?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined }, votes: Array<{ __typename?: 'Vote', count?: number | null | undefined }> }>, owner?: { __typename?: 'User', id: string, name?: string | null | undefined } | null | undefined, thumbnail?: { __typename?: 'PublicFile', id: string, downloadUrl: string } | null | undefined }>, pageInfo: { __typename?: 'Result', totalCount: number } } };

export type PostQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type PostQuery = { __typename?: 'Query', post: { __typename?: 'Post', content: string, id: string, meta?: any | null | undefined, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, viewsCount: number, votesSum?: number | null | undefined, categories: Array<{ __typename?: 'Category', id: string, name: string, slug?: string | null | undefined }>, comments: Array<{ __typename?: 'Comment', contentHtml?: string | null | undefined, id: string, votesSum?: number | null | undefined, updatedAt: any, ownedVote?: { __typename?: 'Vote', count?: number | null | undefined } | null | undefined, user: { __typename?: 'User', id: string, name?: string | null | undefined, avatar?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined }, votes: Array<{ __typename?: 'Vote', count?: number | null | undefined }> }>, owner?: { __typename?: 'User', id: string, name?: string | null | undefined } | null | undefined, thumbnail?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined, relatedBridges: Array<{ __typename?: 'RelatedBridge', createdAt: any, id: string, rowOrder?: number | null | undefined, toId: string, toType: RelatedBridgeTypeEnum, updatedAt: any, to: { __typename?: 'Post', content: string, id: string, meta?: any | null | undefined, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, viewsCount: number, votesSum?: number | null | undefined, updatedAt: any, categories: Array<{ __typename?: 'Category', id: string, name: string }>, comments: Array<{ __typename?: 'Comment', contentHtml?: string | null | undefined, id: string, votesSum?: number | null | undefined, ownedVote?: { __typename?: 'Vote', count?: number | null | undefined } | null | undefined, user: { __typename?: 'User', id: string, name?: string | null | undefined, avatar?: { __typename?: 'PublicFile', id: string, thumbnailUrl: string } | null | undefined }, votes: Array<{ __typename?: 'Vote', count?: number | null | undefined }> }>, owner?: { __typename?: 'User', id: string, name?: string | null | undefined } | null | undefined, thumbnail?: { __typename?: 'PublicFile', id: string, downloadUrl: string } | null | undefined } }>, votes: Array<{ __typename?: 'Vote', count?: number | null | undefined }> } };

export type VotePostMutationVariables = Exact<{
  input: VotePostMutationInput;
}>;

export type VotePostMutation = { __typename?: 'Mutation', votePost?: { __typename?: 'VotePostMutationPayload', vote: { __typename?: 'Vote', count?: number | null | undefined } } | null | undefined };

export type VoteCommentMutationVariables = Exact<{
  input: VoteCommentMutationInput;
}>;

export type VoteCommentMutation = { __typename?: 'Mutation', voteComment?: { __typename?: 'VoteCommentMutationPayload', vote: { __typename?: 'Vote', count?: number | null | undefined } } | null | undefined };

export type TopicTopicSectionsQueryVariables = Exact<{
  topicId: Scalars['ID'];
  paginate?: InputMaybe<PaginateInput>;
}>;

export type TopicTopicSectionsQuery = { __typename?: 'Query', topicTopicSections: { __typename?: 'TopicTopicSectionsSearchResult', node: Array<{ __typename?: 'TopicSection', createdAt: any, id: string, codeSuggestions: Array<{ __typename?: 'CodeSuggestion', content: string, cost: number, createdAt: any, id: string, languageId?: number | null | undefined, topicSectionId: number, updatedAt: any, language?: { __typename?: 'Language', canJudge: boolean, createdAt: any, id: string, name?: string | null | undefined, reactAceKey?: string | null | undefined, updatedAt: any } | null | undefined }>, sectionItem: { __typename?: 'CodingExam', description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, limit: { __typename?: 'CodingExamLimit', memoryLimit?: number | null | undefined, sourceLimit?: number | null | undefined, timeLimit?: number | null | undefined } } | { __typename?: 'CourseLesson', content: string, duration?: number | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, featureImage?: { __typename?: 'PublicFile', downloadUrl: string, filename: string, id: string, metadata: any, thumbnailUrl: string } | null | undefined } | { __typename?: 'GapFillExam', content: string, description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string } | { __typename?: 'OrganizedExam', canRunCode: boolean, content: string, description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string } | { __typename?: 'QuizExam', description?: string | null | undefined, difficulty?: DifficultyEnum | null | undefined, id: string, maxPoints: number, slug?: string | null | undefined, tagList?: Array<string> | null | undefined, title: string, quizQuestBridges: Array<{ __typename?: 'QuizQuestBridge', id: string, quizQuest: { __typename?: 'QuizQuest', description?: string | null | undefined, id: string, isSingleChoice: boolean, name?: string | null | undefined, title?: string | null | undefined, options?: Array<{ __typename?: 'QuizQuestOption', content: string, id: string }> | null | undefined } }> } }>, pageInfo: { __typename?: 'Result', totalPages: number, totalCount: number, currentPage: number } } };

export const MeDocument = gql`
    query Me {
  me {
    address
    avatar {
      thumbnailUrl
    }
    description
    email
    facebookUrl
    id
    linkedinUrl
    name
    role
    referralCode
    practicePoints
    practiceRank
    donePracticesCount
    referredUsersCount
    referrer {
      email
      id
      name
      referralCode
      referredUsersCount
    }
  }
}
    `

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options)
}
export function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options)
}
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;
export const OwnedCoursesDocument = gql`
    query OwnedCourses {
  ownedCourses {
    cover {
      id
      thumbnailUrl
    }
    id
    title
    slug
    lessonsCount
    ownedProgress
    readingTopicSection {
      id
      sectionItem {
        ... on CodingExam {
          slug
        }
        ... on CourseLesson {
          slug
        }
        ... on GapFillExam {
          slug
        }
        ... on OrganizedExam {
          slug
        }
        ... on QuizExam {
          slug
        }
      }
    }
  }
}
    `

/**
 * __useOwnedCoursesQuery__
 *
 * To run a query within a React component, call `useOwnedCoursesQuery` and pass it any options that fit your needs.
 * When your component renders, `useOwnedCoursesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOwnedCoursesQuery({
 *   variables: {
 *   },
 * });
 */
export function useOwnedCoursesQuery(baseOptions?: Apollo.QueryHookOptions<OwnedCoursesQuery, OwnedCoursesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<OwnedCoursesQuery, OwnedCoursesQueryVariables>(OwnedCoursesDocument, options)
}
export function useOwnedCoursesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OwnedCoursesQuery, OwnedCoursesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<OwnedCoursesQuery, OwnedCoursesQueryVariables>(OwnedCoursesDocument, options)
}
export type OwnedCoursesQueryHookResult = ReturnType<typeof useOwnedCoursesQuery>;
export type OwnedCoursesLazyQueryHookResult = ReturnType<typeof useOwnedCoursesLazyQuery>;
export type OwnedCoursesQueryResult = Apollo.QueryResult<OwnedCoursesQuery, OwnedCoursesQueryVariables>;
export const OwnedFavoriteCoursesDocument = gql`
    query OwnedFavoriteCourses($search: String, $fields: [JSON!], $filter: JSON, $order: JSON, $paginate: PaginateInput) {
  ownedFavoriteCourses(
    search: $search
    fields: $fields
    filter: $filter
    order: $order
    paginate: $paginate
  ) {
    node {
      course {
        cover {
          id
          thumbnailUrl
        }
        id
        title
        slug
        lessonsCount
        ownedProgress
        readingTopicSection {
          id
          sectionItem {
            ... on CodingExam {
              slug
            }
            ... on CourseLesson {
              slug
            }
            ... on GapFillExam {
              slug
            }
            ... on OrganizedExam {
              slug
            }
            ... on QuizExam {
              slug
            }
          }
        }
      }
      courseId
      id
    }
    pageInfo {
      totalCount
    }
  }
}
    `

/**
 * __useOwnedFavoriteCoursesQuery__
 *
 * To run a query within a React component, call `useOwnedFavoriteCoursesQuery` and pass it any options that fit your needs.
 * When your component renders, `useOwnedFavoriteCoursesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOwnedFavoriteCoursesQuery({
 *   variables: {
 *      search: // value for 'search'
 *      fields: // value for 'fields'
 *      filter: // value for 'filter'
 *      order: // value for 'order'
 *      paginate: // value for 'paginate'
 *   },
 * });
 */
export function useOwnedFavoriteCoursesQuery(baseOptions?: Apollo.QueryHookOptions<OwnedFavoriteCoursesQuery, OwnedFavoriteCoursesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<OwnedFavoriteCoursesQuery, OwnedFavoriteCoursesQueryVariables>(OwnedFavoriteCoursesDocument, options)
}
export function useOwnedFavoriteCoursesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OwnedFavoriteCoursesQuery, OwnedFavoriteCoursesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<OwnedFavoriteCoursesQuery, OwnedFavoriteCoursesQueryVariables>(OwnedFavoriteCoursesDocument, options)
}
export type OwnedFavoriteCoursesQueryHookResult = ReturnType<typeof useOwnedFavoriteCoursesQuery>;
export type OwnedFavoriteCoursesLazyQueryHookResult = ReturnType<typeof useOwnedFavoriteCoursesLazyQuery>;
export type OwnedFavoriteCoursesQueryResult = Apollo.QueryResult<OwnedFavoriteCoursesQuery, OwnedFavoriteCoursesQueryVariables>;
export const CoursesDocument = gql`
    query Courses($search: String, $fields: [JSON!], $filter: JSON, $order: JSON, $paginate: PaginateInput) {
  courses(
    search: $search
    fields: $fields
    filter: $filter
    order: $order
    paginate: $paginate
  ) {
    node {
      cover {
        id
        thumbnailUrl
      }
      id
      title
      slug
      lessonsCount
    }
    pageInfo {
      totalCount
    }
  }
}
    `

/**
 * __useCoursesQuery__
 *
 * To run a query within a React component, call `useCoursesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCoursesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCoursesQuery({
 *   variables: {
 *      search: // value for 'search'
 *      fields: // value for 'fields'
 *      filter: // value for 'filter'
 *      order: // value for 'order'
 *      paginate: // value for 'paginate'
 *   },
 * });
 */
export function useCoursesQuery(baseOptions?: Apollo.QueryHookOptions<CoursesQuery, CoursesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<CoursesQuery, CoursesQueryVariables>(CoursesDocument, options)
}
export function useCoursesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CoursesQuery, CoursesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<CoursesQuery, CoursesQueryVariables>(CoursesDocument, options)
}
export type CoursesQueryHookResult = ReturnType<typeof useCoursesQuery>;
export type CoursesLazyQueryHookResult = ReturnType<typeof useCoursesLazyQuery>;
export type CoursesQueryResult = Apollo.QueryResult<CoursesQuery, CoursesQueryVariables>;
export const CourseDocument = gql`
    query Course($id: ID!) {
  course(id: $id) {
    categories {
      id
      name
    }
    cover {
      id
      thumbnailUrl
    }
    difficulty
    id
    title
    tagList
    slug
    comments {
      contentHtml
      id
      ownedVote {
        count
      }
      votes {
        count
      }
      votesSum
      user {
        avatar {
          id
          thumbnailUrl
        }
        name
      }
      updatedAt
    }
    description
    duration
    isDraft
    isFavorite
    isFeatured
    isJoined
    isTrending
    lessonsCount
    meta
    examsCount
    ownedProgress
    totalPoints
    topics {
      id
      name
      summary
      topicSections {
        codeSuggestions {
          id
          language {
            canJudge
            id
            name
            reactAceKey
          }
          languageId
          topicSectionId
          cost
        }
        id
        sampleCodes {
          id
          language {
            canJudge
            id
            name
            reactAceKey
          }
          languageId
          topicSectionId
        }
        sectionItem {
          ... on CodingExam {
            description
            difficulty
            id
            limit {
              memoryLimit
              sourceLimit
              timeLimit
            }
            maxPoints
            slug
            tagList
            title
          }
          ... on CourseLesson {
            content
            duration
            featureImage {
              downloadUrl
              filename
              id
              metadata
              thumbnailUrl
            }
            id
            slug
            tagList
            title
          }
          ... on GapFillExam {
            content
            description
            difficulty
            id
            maxPoints
            slug
            tagList
            title
          }
          ... on OrganizedExam {
            canRunCode
            content
            description
            difficulty
            id
            maxPoints
            slug
            tagList
            title
          }
          ... on QuizExam {
            description
            difficulty
            id
            maxPoints
            slug
            tagList
            title
            quizQuestBridges {
              id
              quizQuest {
                description
                id
                isSingleChoice
                name
                options {
                  content
                  id
                }
                title
              }
            }
          }
        }
      }
    }
    readingTopicSection {
      sectionItem {
        ... on CodingExam {
          slug
        }
        ... on CourseLesson {
          slug
        }
        ... on GapFillExam {
          slug
        }
        ... on OrganizedExam {
          slug
        }
        ... on QuizExam {
          slug
        }
      }
    }
  }
}
    `

/**
 * __useCourseQuery__
 *
 * To run a query within a React component, call `useCourseQuery` and pass it any options that fit your needs.
 * When your component renders, `useCourseQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCourseQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCourseQuery(baseOptions: Apollo.QueryHookOptions<CourseQuery, CourseQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<CourseQuery, CourseQueryVariables>(CourseDocument, options)
}
export function useCourseLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CourseQuery, CourseQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<CourseQuery, CourseQueryVariables>(CourseDocument, options)
}
export type CourseQueryHookResult = ReturnType<typeof useCourseQuery>;
export type CourseLazyQueryHookResult = ReturnType<typeof useCourseLazyQuery>;
export type CourseQueryResult = Apollo.QueryResult<CourseQuery, CourseQueryVariables>;
export const PracticesDocument = gql`
    query Practices($search: String, $fields: [JSON!], $filter: JSON, $order: JSON, $paginate: PaginateInput) {
  practices(
    search: $search
    fields: $fields
    filter: $filter
    order: $order
    paginate: $paginate
  ) {
    node {
      cover {
        id
        thumbnailUrl
      }
      id
      title
      slug
      lessonsCount
      examsCount
      ownedProgress
      totalPoints
    }
    pageInfo {
      totalCount
    }
  }
}
    `

/**
 * __usePracticesQuery__
 *
 * To run a query within a React component, call `usePracticesQuery` and pass it any options that fit your needs.
 * When your component renders, `usePracticesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePracticesQuery({
 *   variables: {
 *      search: // value for 'search'
 *      fields: // value for 'fields'
 *      filter: // value for 'filter'
 *      order: // value for 'order'
 *      paginate: // value for 'paginate'
 *   },
 * });
 */
export function usePracticesQuery(baseOptions?: Apollo.QueryHookOptions<PracticesQuery, PracticesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<PracticesQuery, PracticesQueryVariables>(PracticesDocument, options)
}
export function usePracticesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PracticesQuery, PracticesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<PracticesQuery, PracticesQueryVariables>(PracticesDocument, options)
}
export type PracticesQueryHookResult = ReturnType<typeof usePracticesQuery>;
export type PracticesLazyQueryHookResult = ReturnType<typeof usePracticesLazyQuery>;
export type PracticesQueryResult = Apollo.QueryResult<PracticesQuery, PracticesQueryVariables>;
export const PracticeDocument = gql`
    query Practice($id: ID!) {
  practice(id: $id) {
    categories {
      id
      name
    }
    cover {
      id
      thumbnailUrl
    }
    difficulty
    id
    title
    tagList
    slug
    comments {
      contentHtml
      id
      ownedVote {
        count
      }
      votes {
        count
      }
      votesSum
      user {
        avatar {
          id
          thumbnailUrl
        }
        name
      }
      updatedAt
    }
    description
    duration
    isDraft
    isFeatured
    isJoined
    isTrending
    lessonsCount
    meta
    examsCount
    ownedProgress
    totalPoints
    topics {
      id
    }
    languages {
      canJudge
      id
      name
      reactAceKey
    }
  }
}
    `

/**
 * __usePracticeQuery__
 *
 * To run a query within a React component, call `usePracticeQuery` and pass it any options that fit your needs.
 * When your component renders, `usePracticeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePracticeQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePracticeQuery(baseOptions: Apollo.QueryHookOptions<PracticeQuery, PracticeQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<PracticeQuery, PracticeQueryVariables>(PracticeDocument, options)
}
export function usePracticeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PracticeQuery, PracticeQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<PracticeQuery, PracticeQueryVariables>(PracticeDocument, options)
}
export type PracticeQueryHookResult = ReturnType<typeof usePracticeQuery>;
export type PracticeLazyQueryHookResult = ReturnType<typeof usePracticeLazyQuery>;
export type PracticeQueryResult = Apollo.QueryResult<PracticeQuery, PracticeQueryVariables>;
export const PracticeRankListDocument = gql`
    query PracticeRankList($search: String, $fields: [JSON!], $filter: JSON, $order: JSON, $paginate: PaginateInput) {
  practiceRankList(
    search: $search
    fields: $fields
    filter: $filter
    order: $order
    paginate: $paginate
  ) {
    node {
      avatar {
        id
        thumbnailUrl
      }
      id
      name
      practicePoints
    }
    pageInfo {
      totalCount
    }
  }
}
    `

/**
 * __usePracticeRankListQuery__
 *
 * To run a query within a React component, call `usePracticeRankListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePracticeRankListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePracticeRankListQuery({
 *   variables: {
 *      search: // value for 'search'
 *      fields: // value for 'fields'
 *      filter: // value for 'filter'
 *      order: // value for 'order'
 *      paginate: // value for 'paginate'
 *   },
 * });
 */
export function usePracticeRankListQuery(baseOptions?: Apollo.QueryHookOptions<PracticeRankListQuery, PracticeRankListQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<PracticeRankListQuery, PracticeRankListQueryVariables>(PracticeRankListDocument, options)
}
export function usePracticeRankListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PracticeRankListQuery, PracticeRankListQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<PracticeRankListQuery, PracticeRankListQueryVariables>(PracticeRankListDocument, options)
}
export type PracticeRankListQueryHookResult = ReturnType<typeof usePracticeRankListQuery>;
export type PracticeRankListLazyQueryHookResult = ReturnType<typeof usePracticeRankListLazyQuery>;
export type PracticeRankListQueryResult = Apollo.QueryResult<PracticeRankListQuery, PracticeRankListQueryVariables>;
export const JoinProgramDocument = gql`
    mutation JoinProgram($input: JoinProgramMutationInput!) {
  joinProgram(input: $input) {
    programsUser {
      id
      programId
      userId
    }
  }
}
    `
export type JoinProgramMutationFn = Apollo.MutationFunction<JoinProgramMutation, JoinProgramMutationVariables>;

/**
 * __useJoinProgramMutation__
 *
 * To run a mutation, you first call `useJoinProgramMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJoinProgramMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [joinProgramMutation, { data, loading, error }] = useJoinProgramMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useJoinProgramMutation(baseOptions?: Apollo.MutationHookOptions<JoinProgramMutation, JoinProgramMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<JoinProgramMutation, JoinProgramMutationVariables>(JoinProgramDocument, options)
}
export type JoinProgramMutationHookResult = ReturnType<typeof useJoinProgramMutation>;
export type JoinProgramMutationResult = Apollo.MutationResult<JoinProgramMutation>;
export type JoinProgramMutationOptions = Apollo.BaseMutationOptions<JoinProgramMutation, JoinProgramMutationVariables>;
export const ViewTopicSectionDocument = gql`
    mutation ViewTopicSection($input: ViewTopicSectionMutationInput!) {
  viewTopicSection(input: $input) {
    topicSectionView {
      id
      topicSectionId
      userId
    }
  }
}
    `
export type ViewTopicSectionMutationFn = Apollo.MutationFunction<ViewTopicSectionMutation, ViewTopicSectionMutationVariables>;

/**
 * __useViewTopicSectionMutation__
 *
 * To run a mutation, you first call `useViewTopicSectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useViewTopicSectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [viewTopicSectionMutation, { data, loading, error }] = useViewTopicSectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useViewTopicSectionMutation(baseOptions?: Apollo.MutationHookOptions<ViewTopicSectionMutation, ViewTopicSectionMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<ViewTopicSectionMutation, ViewTopicSectionMutationVariables>(ViewTopicSectionDocument, options)
}
export type ViewTopicSectionMutationHookResult = ReturnType<typeof useViewTopicSectionMutation>;
export type ViewTopicSectionMutationResult = Apollo.MutationResult<ViewTopicSectionMutation>;
export type ViewTopicSectionMutationOptions = Apollo.BaseMutationOptions<ViewTopicSectionMutation, ViewTopicSectionMutationVariables>;
export const CreateCommentDocument = gql`
    mutation CreateComment($input: CreateCommentMutationInput!) {
  createComment(input: $input) {
    comment {
      id
    }
  }
}
    `
export type CreateCommentMutationFn = Apollo.MutationFunction<CreateCommentMutation, CreateCommentMutationVariables>;

/**
 * __useCreateCommentMutation__
 *
 * To run a mutation, you first call `useCreateCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCommentMutation, { data, loading, error }] = useCreateCommentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCommentMutation(baseOptions?: Apollo.MutationHookOptions<CreateCommentMutation, CreateCommentMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateCommentMutation, CreateCommentMutationVariables>(CreateCommentDocument, options)
}
export type CreateCommentMutationHookResult = ReturnType<typeof useCreateCommentMutation>;
export type CreateCommentMutationResult = Apollo.MutationResult<CreateCommentMutation>;
export type CreateCommentMutationOptions = Apollo.BaseMutationOptions<CreateCommentMutation, CreateCommentMutationVariables>;
export const RemoveCoursesFromFavoriteDocument = gql`
    mutation RemoveCoursesFromFavorite($input: RemoveCoursesFromFavoriteMutationInput!) {
  removeCoursesFromFavorite(input: $input) {
    status
  }
}
    `
export type RemoveCoursesFromFavoriteMutationFn = Apollo.MutationFunction<RemoveCoursesFromFavoriteMutation, RemoveCoursesFromFavoriteMutationVariables>;

/**
 * __useRemoveCoursesFromFavoriteMutation__
 *
 * To run a mutation, you first call `useRemoveCoursesFromFavoriteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveCoursesFromFavoriteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeCoursesFromFavoriteMutation, { data, loading, error }] = useRemoveCoursesFromFavoriteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveCoursesFromFavoriteMutation(baseOptions?: Apollo.MutationHookOptions<RemoveCoursesFromFavoriteMutation, RemoveCoursesFromFavoriteMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<RemoveCoursesFromFavoriteMutation, RemoveCoursesFromFavoriteMutationVariables>(RemoveCoursesFromFavoriteDocument, options)
}
export type RemoveCoursesFromFavoriteMutationHookResult = ReturnType<typeof useRemoveCoursesFromFavoriteMutation>;
export type RemoveCoursesFromFavoriteMutationResult = Apollo.MutationResult<RemoveCoursesFromFavoriteMutation>;
export type RemoveCoursesFromFavoriteMutationOptions = Apollo.BaseMutationOptions<RemoveCoursesFromFavoriteMutation, RemoveCoursesFromFavoriteMutationVariables>;
export const CreateFavoriteCourseDocument = gql`
    mutation CreateFavoriteCourse($input: CreateFavoriteCourseMutationInput!) {
  createFavoriteCourse(input: $input) {
    favoriteCourse {
      id
    }
  }
}
    `
export type CreateFavoriteCourseMutationFn = Apollo.MutationFunction<CreateFavoriteCourseMutation, CreateFavoriteCourseMutationVariables>;

/**
 * __useCreateFavoriteCourseMutation__
 *
 * To run a mutation, you first call `useCreateFavoriteCourseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFavoriteCourseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFavoriteCourseMutation, { data, loading, error }] = useCreateFavoriteCourseMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateFavoriteCourseMutation(baseOptions?: Apollo.MutationHookOptions<CreateFavoriteCourseMutation, CreateFavoriteCourseMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateFavoriteCourseMutation, CreateFavoriteCourseMutationVariables>(CreateFavoriteCourseDocument, options)
}
export type CreateFavoriteCourseMutationHookResult = ReturnType<typeof useCreateFavoriteCourseMutation>;
export type CreateFavoriteCourseMutationResult = Apollo.MutationResult<CreateFavoriteCourseMutation>;
export type CreateFavoriteCourseMutationOptions = Apollo.BaseMutationOptions<CreateFavoriteCourseMutation, CreateFavoriteCourseMutationVariables>;
export const CreateCodeSuggestionRequestDocument = gql`
    mutation CreateCodeSuggestionRequest($input: CreateCodeSuggestionRequestMutationInput!) {
  createCodeSuggestionRequest(input: $input) {
    codeSuggestionRequest {
      codeSuggestionId
      content
      cost
      id
    }
  }
}
    `
export type CreateCodeSuggestionRequestMutationFn = Apollo.MutationFunction<CreateCodeSuggestionRequestMutation, CreateCodeSuggestionRequestMutationVariables>;

/**
 * __useCreateCodeSuggestionRequestMutation__
 *
 * To run a mutation, you first call `useCreateCodeSuggestionRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCodeSuggestionRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCodeSuggestionRequestMutation, { data, loading, error }] = useCreateCodeSuggestionRequestMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCodeSuggestionRequestMutation(baseOptions?: Apollo.MutationHookOptions<CreateCodeSuggestionRequestMutation, CreateCodeSuggestionRequestMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateCodeSuggestionRequestMutation, CreateCodeSuggestionRequestMutationVariables>(CreateCodeSuggestionRequestDocument, options)
}
export type CreateCodeSuggestionRequestMutationHookResult = ReturnType<typeof useCreateCodeSuggestionRequestMutation>;
export type CreateCodeSuggestionRequestMutationResult = Apollo.MutationResult<CreateCodeSuggestionRequestMutation>;
export type CreateCodeSuggestionRequestMutationOptions = Apollo.BaseMutationOptions<CreateCodeSuggestionRequestMutation, CreateCodeSuggestionRequestMutationVariables>;
export const CourseLessonDocument = gql`
    query CourseLesson($id: ID!) {
  courseLesson(id: $id) {
    content
    duration
    featureImage {
      id
      thumbnailUrl
    }
    id
    slug
    tagList
    title
  }
}
    `

/**
 * __useCourseLessonQuery__
 *
 * To run a query within a React component, call `useCourseLessonQuery` and pass it any options that fit your needs.
 * When your component renders, `useCourseLessonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCourseLessonQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCourseLessonQuery(baseOptions: Apollo.QueryHookOptions<CourseLessonQuery, CourseLessonQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<CourseLessonQuery, CourseLessonQueryVariables>(CourseLessonDocument, options)
}
export function useCourseLessonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CourseLessonQuery, CourseLessonQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<CourseLessonQuery, CourseLessonQueryVariables>(CourseLessonDocument, options)
}
export type CourseLessonQueryHookResult = ReturnType<typeof useCourseLessonQuery>;
export type CourseLessonLazyQueryHookResult = ReturnType<typeof useCourseLessonLazyQuery>;
export type CourseLessonQueryResult = Apollo.QueryResult<CourseLessonQuery, CourseLessonQueryVariables>;
export const QuizExamDocument = gql`
    query QuizExam($id: ID!) {
  quizExam(id: $id) {
    description
    difficulty
    id
    maxPoints
    slug
    tagList
    title
    quizQuestBridges {
      id
      quizQuest {
        id
        description
        isSingleChoice
        name
        options {
          id
          content
          isChecked
        }
        title
      }
      rowOrder
    }
  }
}
    `

/**
 * __useQuizExamQuery__
 *
 * To run a query within a React component, call `useQuizExamQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuizExamQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuizExamQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useQuizExamQuery(baseOptions: Apollo.QueryHookOptions<QuizExamQuery, QuizExamQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QuizExamQuery, QuizExamQueryVariables>(QuizExamDocument, options)
}
export function useQuizExamLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QuizExamQuery, QuizExamQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QuizExamQuery, QuizExamQueryVariables>(QuizExamDocument, options)
}
export type QuizExamQueryHookResult = ReturnType<typeof useQuizExamQuery>;
export type QuizExamLazyQueryHookResult = ReturnType<typeof useQuizExamLazyQuery>;
export type QuizExamQueryResult = Apollo.QueryResult<QuizExamQuery, QuizExamQueryVariables>;
export const QuizQuestDocument = gql`
    query QuizQuest($id: ID!) {
  quizQuest(id: $id) {
    description
    id
    isSingleChoice
    name
    options {
      content
      id
      isChecked
    }
    title
  }
}
    `

/**
 * __useQuizQuestQuery__
 *
 * To run a query within a React component, call `useQuizQuestQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuizQuestQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuizQuestQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useQuizQuestQuery(baseOptions: Apollo.QueryHookOptions<QuizQuestQuery, QuizQuestQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QuizQuestQuery, QuizQuestQueryVariables>(QuizQuestDocument, options)
}
export function useQuizQuestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QuizQuestQuery, QuizQuestQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QuizQuestQuery, QuizQuestQueryVariables>(QuizQuestDocument, options)
}
export type QuizQuestQueryHookResult = ReturnType<typeof useQuizQuestQuery>;
export type QuizQuestLazyQueryHookResult = ReturnType<typeof useQuizQuestLazyQuery>;
export type QuizQuestQueryResult = Apollo.QueryResult<QuizQuestQuery, QuizQuestQueryVariables>;
export const CreateQuizExamSubmissionDocument = gql`
    mutation CreateQuizExamSubmission($input: CreateQuizExamSubmissionMutationInput!) {
  createQuizExamSubmission(input: $input) {
    quizExamSubmission {
      id
      correctRatio
      judgedResult {
        checkedOptionIds
        isCorrect
        quizQuestId
      }
      stat {
        correctCount
        totalCount
      }
      totalPoints
    }
  }
}
    `
export type CreateQuizExamSubmissionMutationFn = Apollo.MutationFunction<CreateQuizExamSubmissionMutation, CreateQuizExamSubmissionMutationVariables>;

/**
 * __useCreateQuizExamSubmissionMutation__
 *
 * To run a mutation, you first call `useCreateQuizExamSubmissionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateQuizExamSubmissionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createQuizExamSubmissionMutation, { data, loading, error }] = useCreateQuizExamSubmissionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateQuizExamSubmissionMutation(baseOptions?: Apollo.MutationHookOptions<CreateQuizExamSubmissionMutation, CreateQuizExamSubmissionMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateQuizExamSubmissionMutation, CreateQuizExamSubmissionMutationVariables>(CreateQuizExamSubmissionDocument, options)
}
export type CreateQuizExamSubmissionMutationHookResult = ReturnType<typeof useCreateQuizExamSubmissionMutation>;
export type CreateQuizExamSubmissionMutationResult = Apollo.MutationResult<CreateQuizExamSubmissionMutation>;
export type CreateQuizExamSubmissionMutationOptions = Apollo.BaseMutationOptions<CreateQuizExamSubmissionMutation, CreateQuizExamSubmissionMutationVariables>;
export const GapFillExamDocument = gql`
    query GapFillExam($id: ID!, $programId: ID!) {
  gapFillExam(id: $id) {
    content
    description
    difficulty
    gapValues
    id
    isIgnoreCase
    maxPoints
    slug
    tagList
    title
    topicSection(programId: $programId) {
      codeSuggestions {
        id
        cost
      }
    }
  }
}
    `

/**
 * __useGapFillExamQuery__
 *
 * To run a query within a React component, call `useGapFillExamQuery` and pass it any options that fit your needs.
 * When your component renders, `useGapFillExamQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGapFillExamQuery({
 *   variables: {
 *      id: // value for 'id'
 *      programId: // value for 'programId'
 *   },
 * });
 */
export function useGapFillExamQuery(baseOptions: Apollo.QueryHookOptions<GapFillExamQuery, GapFillExamQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GapFillExamQuery, GapFillExamQueryVariables>(GapFillExamDocument, options)
}
export function useGapFillExamLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GapFillExamQuery, GapFillExamQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GapFillExamQuery, GapFillExamQueryVariables>(GapFillExamDocument, options)
}
export type GapFillExamQueryHookResult = ReturnType<typeof useGapFillExamQuery>;
export type GapFillExamLazyQueryHookResult = ReturnType<typeof useGapFillExamLazyQuery>;
export type GapFillExamQueryResult = Apollo.QueryResult<GapFillExamQuery, GapFillExamQueryVariables>;
export const CreateGapFillExamSubmissionDocument = gql`
    mutation CreateGapFillExamSubmission($input: CreateGapFillExamSubmissionMutationInput!) {
  createGapFillExamSubmission(input: $input) {
    gapFillExamSubmission {
      id
      correctRatio
      filledValues
      judgedResult {
        index
        isCorrect
      }
      stat {
        correctCount
        totalCount
      }
      totalPoints
    }
  }
}
    `
export type CreateGapFillExamSubmissionMutationFn = Apollo.MutationFunction<CreateGapFillExamSubmissionMutation, CreateGapFillExamSubmissionMutationVariables>;

/**
 * __useCreateGapFillExamSubmissionMutation__
 *
 * To run a mutation, you first call `useCreateGapFillExamSubmissionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGapFillExamSubmissionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGapFillExamSubmissionMutation, { data, loading, error }] = useCreateGapFillExamSubmissionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateGapFillExamSubmissionMutation(baseOptions?: Apollo.MutationHookOptions<CreateGapFillExamSubmissionMutation, CreateGapFillExamSubmissionMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateGapFillExamSubmissionMutation, CreateGapFillExamSubmissionMutationVariables>(CreateGapFillExamSubmissionDocument, options)
}
export type CreateGapFillExamSubmissionMutationHookResult = ReturnType<typeof useCreateGapFillExamSubmissionMutation>;
export type CreateGapFillExamSubmissionMutationResult = Apollo.MutationResult<CreateGapFillExamSubmissionMutation>;
export type CreateGapFillExamSubmissionMutationOptions = Apollo.BaseMutationOptions<CreateGapFillExamSubmissionMutation, CreateGapFillExamSubmissionMutationVariables>;
export const CodingExamDocument = gql`
    query CodingExam($id: ID!, $programId: ID!) {
  codingExam(id: $id) {
    description
    difficulty
    limit {
      memoryLimit
      timeLimit
      sourceLimit
    }
    id
    maxPoints
    slug
    tagList
    testCases {
      input
      output
    }
    testCasesFile {
      id
      metadata
      filename
    }
    title
    topicSection(programId: $programId) {
      codeSuggestions {
        cost
        id
        language {
          canJudge
          id
          name
          reactAceKey
        }
        languageId
        topicSectionId
      }
      sampleCodes {
        id
        language {
          canJudge
          id
          name
          reactAceKey
        }
        languageId
        topicSectionId
        code
      }
    }
  }
}
    `

/**
 * __useCodingExamQuery__
 *
 * To run a query within a React component, call `useCodingExamQuery` and pass it any options that fit your needs.
 * When your component renders, `useCodingExamQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCodingExamQuery({
 *   variables: {
 *      id: // value for 'id'
 *      programId: // value for 'programId'
 *   },
 * });
 */
export function useCodingExamQuery(baseOptions: Apollo.QueryHookOptions<CodingExamQuery, CodingExamQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<CodingExamQuery, CodingExamQueryVariables>(CodingExamDocument, options)
}
export function useCodingExamLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CodingExamQuery, CodingExamQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<CodingExamQuery, CodingExamQueryVariables>(CodingExamDocument, options)
}
export type CodingExamQueryHookResult = ReturnType<typeof useCodingExamQuery>;
export type CodingExamLazyQueryHookResult = ReturnType<typeof useCodingExamLazyQuery>;
export type CodingExamQueryResult = Apollo.QueryResult<CodingExamQuery, CodingExamQueryVariables>;
export const CreateCodingExamSubmissionDocument = gql`
    mutation CreateCodingExamSubmission($input: CreateCodingExamSubmissionMutationInput!) {
  createCodingExamSubmission(input: $input) {
    codingExamSubmission {
      caseResults
      correctRatio
      error {
        message
        type
      }
      id
      isJudged
      language {
        canJudge
        id
        name
        reactAceKey
      }
      src
      stat {
        correctCount
        totalCount
      }
      totalPoints
    }
  }
}
    `
export type CreateCodingExamSubmissionMutationFn = Apollo.MutationFunction<CreateCodingExamSubmissionMutation, CreateCodingExamSubmissionMutationVariables>;

/**
 * __useCreateCodingExamSubmissionMutation__
 *
 * To run a mutation, you first call `useCreateCodingExamSubmissionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCodingExamSubmissionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCodingExamSubmissionMutation, { data, loading, error }] = useCreateCodingExamSubmissionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCodingExamSubmissionMutation(baseOptions?: Apollo.MutationHookOptions<CreateCodingExamSubmissionMutation, CreateCodingExamSubmissionMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateCodingExamSubmissionMutation, CreateCodingExamSubmissionMutationVariables>(CreateCodingExamSubmissionDocument, options)
}
export type CreateCodingExamSubmissionMutationHookResult = ReturnType<typeof useCreateCodingExamSubmissionMutation>;
export type CreateCodingExamSubmissionMutationResult = Apollo.MutationResult<CreateCodingExamSubmissionMutation>;
export type CreateCodingExamSubmissionMutationOptions = Apollo.BaseMutationOptions<CreateCodingExamSubmissionMutation, CreateCodingExamSubmissionMutationVariables>;
export const CodingExamSubmissionJudgedDocument = gql`
    subscription CodingExamSubmissionJudged($id: ID!) {
  codingExamSubmissionJudged(id: $id) {
    caseResults
    correctRatio
    error {
      message
      type
    }
    id
    isJudged
    language {
      canJudge
      createdAt
      id
      name
      reactAceKey
    }
    src
    stat {
      correctCount
      totalCount
    }
    totalPoints
  }
}
    `

/**
 * __useCodingExamSubmissionJudgedSubscription__
 *
 * To run a query within a React component, call `useCodingExamSubmissionJudgedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useCodingExamSubmissionJudgedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCodingExamSubmissionJudgedSubscription({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCodingExamSubmissionJudgedSubscription(baseOptions: Apollo.SubscriptionHookOptions<CodingExamSubmissionJudgedSubscription, CodingExamSubmissionJudgedSubscriptionVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSubscription<CodingExamSubmissionJudgedSubscription, CodingExamSubmissionJudgedSubscriptionVariables>(CodingExamSubmissionJudgedDocument, options)
}
export type CodingExamSubmissionJudgedSubscriptionHookResult = ReturnType<typeof useCodingExamSubmissionJudgedSubscription>;
export type CodingExamSubmissionJudgedSubscriptionResult = Apollo.SubscriptionResult<CodingExamSubmissionJudgedSubscription>;
export const OrganizedExamDocument = gql`
    query OrganizedExam($id: ID!, $programId: ID!) {
  organizedExam(id: $id) {
    allowList
    canRunCode
    content
    maxPoints
    id
    difficulty
    description
    denyList
    title
    tagList
    slug
    topicSection(programId: $programId) {
      codeSuggestions {
        cost
        id
        language {
          canJudge
          id
          name
          reactAceKey
        }
        languageId
        topicSectionId
      }
      sampleCodes {
        id
        language {
          canJudge
          id
          name
          reactAceKey
        }
        languageId
        topicSectionId
        code
      }
    }
  }
}
    `

/**
 * __useOrganizedExamQuery__
 *
 * To run a query within a React component, call `useOrganizedExamQuery` and pass it any options that fit your needs.
 * When your component renders, `useOrganizedExamQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOrganizedExamQuery({
 *   variables: {
 *      id: // value for 'id'
 *      programId: // value for 'programId'
 *   },
 * });
 */
export function useOrganizedExamQuery(baseOptions: Apollo.QueryHookOptions<OrganizedExamQuery, OrganizedExamQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<OrganizedExamQuery, OrganizedExamQueryVariables>(OrganizedExamDocument, options)
}
export function useOrganizedExamLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OrganizedExamQuery, OrganizedExamQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<OrganizedExamQuery, OrganizedExamQueryVariables>(OrganizedExamDocument, options)
}
export type OrganizedExamQueryHookResult = ReturnType<typeof useOrganizedExamQuery>;
export type OrganizedExamLazyQueryHookResult = ReturnType<typeof useOrganizedExamLazyQuery>;
export type OrganizedExamQueryResult = Apollo.QueryResult<OrganizedExamQuery, OrganizedExamQueryVariables>;
export const CreateOrganizedExamSubmissionDocument = gql`
    mutation CreateOrganizedExamSubmission($input: CreateOrganizedExamSubmissionMutationInput!) {
  createOrganizedExamSubmission(input: $input) {
    organizedExamSubmission {
      content
      correctRatio
      id
      mistake {
        missingKeyword
        prohibitKeywords
      }
      stat {
        correctCount
        totalCount
      }
      totalPoints
    }
  }
}
    `
export type CreateOrganizedExamSubmissionMutationFn = Apollo.MutationFunction<CreateOrganizedExamSubmissionMutation, CreateOrganizedExamSubmissionMutationVariables>;

/**
 * __useCreateOrganizedExamSubmissionMutation__
 *
 * To run a mutation, you first call `useCreateOrganizedExamSubmissionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOrganizedExamSubmissionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOrganizedExamSubmissionMutation, { data, loading, error }] = useCreateOrganizedExamSubmissionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateOrganizedExamSubmissionMutation(baseOptions?: Apollo.MutationHookOptions<CreateOrganizedExamSubmissionMutation, CreateOrganizedExamSubmissionMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateOrganizedExamSubmissionMutation, CreateOrganizedExamSubmissionMutationVariables>(CreateOrganizedExamSubmissionDocument, options)
}
export type CreateOrganizedExamSubmissionMutationHookResult = ReturnType<typeof useCreateOrganizedExamSubmissionMutation>;
export type CreateOrganizedExamSubmissionMutationResult = Apollo.MutationResult<CreateOrganizedExamSubmissionMutation>;
export type CreateOrganizedExamSubmissionMutationOptions = Apollo.BaseMutationOptions<CreateOrganizedExamSubmissionMutation, CreateOrganizedExamSubmissionMutationVariables>;
export const JdoodleExecuteDocument = gql`
    mutation JdoodleExecute($input: JdoodleExecuteMutationInput!) {
  jdoodleExecute(input: $input) {
    response {
      body
      status
    }
  }
}
    `
export type JdoodleExecuteMutationFn = Apollo.MutationFunction<JdoodleExecuteMutation, JdoodleExecuteMutationVariables>;

/**
 * __useJdoodleExecuteMutation__
 *
 * To run a mutation, you first call `useJdoodleExecuteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJdoodleExecuteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [jdoodleExecuteMutation, { data, loading, error }] = useJdoodleExecuteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useJdoodleExecuteMutation(baseOptions?: Apollo.MutationHookOptions<JdoodleExecuteMutation, JdoodleExecuteMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<JdoodleExecuteMutation, JdoodleExecuteMutationVariables>(JdoodleExecuteDocument, options)
}
export type JdoodleExecuteMutationHookResult = ReturnType<typeof useJdoodleExecuteMutation>;
export type JdoodleExecuteMutationResult = Apollo.MutationResult<JdoodleExecuteMutation>;
export type JdoodleExecuteMutationOptions = Apollo.BaseMutationOptions<JdoodleExecuteMutation, JdoodleExecuteMutationVariables>;
export const CategoriesDocument = gql`
    query Categories($search: String, $fields: [JSON!], $filter: JSON, $order: JSON, $paginate: PaginateInput) {
  categories(
    search: $search
    fields: $fields
    filter: $filter
    order: $order
    paginate: $paginate
  ) {
    node {
      id
      name
      slug
    }
  }
}
    `

/**
 * __useCategoriesQuery__
 *
 * To run a query within a React component, call `useCategoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCategoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCategoriesQuery({
 *   variables: {
 *      search: // value for 'search'
 *      fields: // value for 'fields'
 *      filter: // value for 'filter'
 *      order: // value for 'order'
 *      paginate: // value for 'paginate'
 *   },
 * });
 */
export function useCategoriesQuery(baseOptions?: Apollo.QueryHookOptions<CategoriesQuery, CategoriesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<CategoriesQuery, CategoriesQueryVariables>(CategoriesDocument, options)
}
export function useCategoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CategoriesQuery, CategoriesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<CategoriesQuery, CategoriesQueryVariables>(CategoriesDocument, options)
}
export type CategoriesQueryHookResult = ReturnType<typeof useCategoriesQuery>;
export type CategoriesLazyQueryHookResult = ReturnType<typeof useCategoriesLazyQuery>;
export type CategoriesQueryResult = Apollo.QueryResult<CategoriesQuery, CategoriesQueryVariables>;
export const TagsDocument = gql`
    query Tags($search: String, $fields: [JSON!], $filter: JSON, $order: JSON, $paginate: PaginateInput) {
  tags(
    search: $search
    fields: $fields
    filter: $filter
    order: $order
    paginate: $paginate
  ) {
    node {
      id
      name
    }
  }
}
    `

/**
 * __useTagsQuery__
 *
 * To run a query within a React component, call `useTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTagsQuery({
 *   variables: {
 *      search: // value for 'search'
 *      fields: // value for 'fields'
 *      filter: // value for 'filter'
 *      order: // value for 'order'
 *      paginate: // value for 'paginate'
 *   },
 * });
 */
export function useTagsQuery(baseOptions?: Apollo.QueryHookOptions<TagsQuery, TagsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<TagsQuery, TagsQueryVariables>(TagsDocument, options)
}
export function useTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TagsQuery, TagsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<TagsQuery, TagsQueryVariables>(TagsDocument, options)
}
export type TagsQueryHookResult = ReturnType<typeof useTagsQuery>;
export type TagsLazyQueryHookResult = ReturnType<typeof useTagsLazyQuery>;
export type TagsQueryResult = Apollo.QueryResult<TagsQuery, TagsQueryVariables>;
export const AllLanguagesDocument = gql`
    query AllLanguages {
  allLanguages {
    id
    name
    reactAceKey
  }
}
    `

/**
 * __useAllLanguagesQuery__
 *
 * To run a query within a React component, call `useAllLanguagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllLanguagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllLanguagesQuery({
 *   variables: {
 *   },
 * });
 */
export function useAllLanguagesQuery(baseOptions?: Apollo.QueryHookOptions<AllLanguagesQuery, AllLanguagesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<AllLanguagesQuery, AllLanguagesQueryVariables>(AllLanguagesDocument, options)
}
export function useAllLanguagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllLanguagesQuery, AllLanguagesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<AllLanguagesQuery, AllLanguagesQueryVariables>(AllLanguagesDocument, options)
}
export type AllLanguagesQueryHookResult = ReturnType<typeof useAllLanguagesQuery>;
export type AllLanguagesLazyQueryHookResult = ReturnType<typeof useAllLanguagesLazyQuery>;
export type AllLanguagesQueryResult = Apollo.QueryResult<AllLanguagesQuery, AllLanguagesQueryVariables>;
export const LearningPathsDocument = gql`
    query LearningPaths($search: String, $fields: [JSON!], $filter: JSON, $order: JSON, $paginate: PaginateInput) {
  learningPaths(
    search: $search
    fields: $fields
    filter: $filter
    order: $order
    paginate: $paginate
  ) {
    node {
      id
      slug
      title
    }
    pageInfo {
      totalCount
    }
  }
}
    `

/**
 * __useLearningPathsQuery__
 *
 * To run a query within a React component, call `useLearningPathsQuery` and pass it any options that fit your needs.
 * When your component renders, `useLearningPathsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLearningPathsQuery({
 *   variables: {
 *      search: // value for 'search'
 *      fields: // value for 'fields'
 *      filter: // value for 'filter'
 *      order: // value for 'order'
 *      paginate: // value for 'paginate'
 *   },
 * });
 */
export function useLearningPathsQuery(baseOptions?: Apollo.QueryHookOptions<LearningPathsQuery, LearningPathsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<LearningPathsQuery, LearningPathsQueryVariables>(LearningPathsDocument, options)
}
export function useLearningPathsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LearningPathsQuery, LearningPathsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<LearningPathsQuery, LearningPathsQueryVariables>(LearningPathsDocument, options)
}
export type LearningPathsQueryHookResult = ReturnType<typeof useLearningPathsQuery>;
export type LearningPathsLazyQueryHookResult = ReturnType<typeof useLearningPathsLazyQuery>;
export type LearningPathsQueryResult = Apollo.QueryResult<LearningPathsQuery, LearningPathsQueryVariables>;
export const LearningPathDocument = gql`
    query LearningPath($id: ID!) {
  learningPath(id: $id) {
    benefits
    benefitsSummary
    cover {
      id
      thumbnailUrl
    }
    description
    difficulty
    duration
    id
    includes
    isJoined
    learningPathsPrograms {
      program {
        id
        slug
        title
        description
      }
      id
    }
    meta
    ownedProgress
    projects
    reading {
      courseSlug
      sectionItemSlug
    }
    slug
    summary
    tagList
    target
    title
  }
}
    `

/**
 * __useLearningPathQuery__
 *
 * To run a query within a React component, call `useLearningPathQuery` and pass it any options that fit your needs.
 * When your component renders, `useLearningPathQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLearningPathQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useLearningPathQuery(baseOptions: Apollo.QueryHookOptions<LearningPathQuery, LearningPathQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<LearningPathQuery, LearningPathQueryVariables>(LearningPathDocument, options)
}
export function useLearningPathLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LearningPathQuery, LearningPathQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<LearningPathQuery, LearningPathQueryVariables>(LearningPathDocument, options)
}
export type LearningPathQueryHookResult = ReturnType<typeof useLearningPathQuery>;
export type LearningPathLazyQueryHookResult = ReturnType<typeof useLearningPathLazyQuery>;
export type LearningPathQueryResult = Apollo.QueryResult<LearningPathQuery, LearningPathQueryVariables>;
export const JoinLearningPathDocument = gql`
    mutation JoinLearningPath($input: JoinLearningPathMutationInput!) {
  joinLearningPath(input: $input) {
    status
  }
}
    `
export type JoinLearningPathMutationFn = Apollo.MutationFunction<JoinLearningPathMutation, JoinLearningPathMutationVariables>;

/**
 * __useJoinLearningPathMutation__
 *
 * To run a mutation, you first call `useJoinLearningPathMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJoinLearningPathMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [joinLearningPathMutation, { data, loading, error }] = useJoinLearningPathMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useJoinLearningPathMutation(baseOptions?: Apollo.MutationHookOptions<JoinLearningPathMutation, JoinLearningPathMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<JoinLearningPathMutation, JoinLearningPathMutationVariables>(JoinLearningPathDocument, options)
}
export type JoinLearningPathMutationHookResult = ReturnType<typeof useJoinLearningPathMutation>;
export type JoinLearningPathMutationResult = Apollo.MutationResult<JoinLearningPathMutation>;
export type JoinLearningPathMutationOptions = Apollo.BaseMutationOptions<JoinLearningPathMutation, JoinLearningPathMutationVariables>;
export const UsersDocument = gql`
    query Users($search: String, $fields: [JSON!], $filter: JSON, $order: JSON, $paginate: PaginateInput) {
  users(
    search: $search
    fields: $fields
    filter: $filter
    order: $order
    paginate: $paginate
  ) {
    node {
      avatar {
        id
        thumbnailUrl
      }
      faqVotes
      id
      name
      practicePoints
      donePracticesCount
      referredUsersCount
    }
    pageInfo {
      totalCount
    }
  }
}
    `

/**
 * __useUsersQuery__
 *
 * To run a query within a React component, call `useUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsersQuery({
 *   variables: {
 *      search: // value for 'search'
 *      fields: // value for 'fields'
 *      filter: // value for 'filter'
 *      order: // value for 'order'
 *      paginate: // value for 'paginate'
 *   },
 * });
 */
export function useUsersQuery(baseOptions?: Apollo.QueryHookOptions<UsersQuery, UsersQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options)
}
export function useUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsersQuery, UsersQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options)
}
export type UsersQueryHookResult = ReturnType<typeof useUsersQuery>;
export type UsersLazyQueryHookResult = ReturnType<typeof useUsersLazyQuery>;
export type UsersQueryResult = Apollo.QueryResult<UsersQuery, UsersQueryVariables>;
export const PostsDocument = gql`
    query Posts($search: String, $fields: [JSON!], $filter: JSON, $order: JSON, $paginate: PaginateInput) {
  posts(
    search: $search
    fields: $fields
    filter: $filter
    order: $order
    paginate: $paginate
  ) {
    node {
      categories {
        id
        name
      }
      comments {
        contentHtml
        id
        ownedVote {
          count
        }
        user {
          avatar {
            id
            thumbnailUrl
          }
          id
          name
        }
        votes {
          count
        }
        votesSum
      }
      content
      id
      meta
      owner {
        id
        name
      }
      slug
      tagList
      thumbnail {
        id
        downloadUrl
      }
      title
      viewsCount
      votesSum
      updatedAt
    }
    pageInfo {
      totalCount
    }
  }
}
    `

/**
 * __usePostsQuery__
 *
 * To run a query within a React component, call `usePostsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePostsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePostsQuery({
 *   variables: {
 *      search: // value for 'search'
 *      fields: // value for 'fields'
 *      filter: // value for 'filter'
 *      order: // value for 'order'
 *      paginate: // value for 'paginate'
 *   },
 * });
 */
export function usePostsQuery(baseOptions?: Apollo.QueryHookOptions<PostsQuery, PostsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<PostsQuery, PostsQueryVariables>(PostsDocument, options)
}
export function usePostsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PostsQuery, PostsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<PostsQuery, PostsQueryVariables>(PostsDocument, options)
}
export type PostsQueryHookResult = ReturnType<typeof usePostsQuery>;
export type PostsLazyQueryHookResult = ReturnType<typeof usePostsLazyQuery>;
export type PostsQueryResult = Apollo.QueryResult<PostsQuery, PostsQueryVariables>;
export const PostDocument = gql`
    query Post($id: ID!) {
  post(id: $id) {
    categories {
      id
      name
      slug
    }
    comments {
      contentHtml
      id
      ownedVote {
        count
      }
      user {
        avatar {
          id
          thumbnailUrl
        }
        id
        name
      }
      votes {
        count
      }
      votesSum
      updatedAt
    }
    content
    id
    meta
    owner {
      id
      name
    }
    slug
    tagList
    thumbnail {
      id
      thumbnailUrl
    }
    title
    relatedBridges {
      createdAt
      id
      rowOrder
      to {
        ... on Post {
          categories {
            id
            name
          }
          comments {
            contentHtml
            id
            ownedVote {
              count
            }
            user {
              avatar {
                id
                thumbnailUrl
              }
              id
              name
            }
            votes {
              count
            }
            votesSum
          }
          content
          id
          meta
          owner {
            id
            name
          }
          slug
          tagList
          thumbnail {
            id
            downloadUrl
          }
          title
          viewsCount
          votesSum
          updatedAt
        }
      }
      toId
      toType
      updatedAt
    }
    viewsCount
    votes {
      count
    }
    votesSum
  }
}
    `

/**
 * __usePostQuery__
 *
 * To run a query within a React component, call `usePostQuery` and pass it any options that fit your needs.
 * When your component renders, `usePostQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePostQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePostQuery(baseOptions: Apollo.QueryHookOptions<PostQuery, PostQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<PostQuery, PostQueryVariables>(PostDocument, options)
}
export function usePostLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PostQuery, PostQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<PostQuery, PostQueryVariables>(PostDocument, options)
}
export type PostQueryHookResult = ReturnType<typeof usePostQuery>;
export type PostLazyQueryHookResult = ReturnType<typeof usePostLazyQuery>;
export type PostQueryResult = Apollo.QueryResult<PostQuery, PostQueryVariables>;
export const VotePostDocument = gql`
    mutation VotePost($input: VotePostMutationInput!) {
  votePost(input: $input) {
    vote {
      count
    }
  }
}
    `
export type VotePostMutationFn = Apollo.MutationFunction<VotePostMutation, VotePostMutationVariables>;

/**
 * __useVotePostMutation__
 *
 * To run a mutation, you first call `useVotePostMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVotePostMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [votePostMutation, { data, loading, error }] = useVotePostMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useVotePostMutation(baseOptions?: Apollo.MutationHookOptions<VotePostMutation, VotePostMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<VotePostMutation, VotePostMutationVariables>(VotePostDocument, options)
}
export type VotePostMutationHookResult = ReturnType<typeof useVotePostMutation>;
export type VotePostMutationResult = Apollo.MutationResult<VotePostMutation>;
export type VotePostMutationOptions = Apollo.BaseMutationOptions<VotePostMutation, VotePostMutationVariables>;
export const VoteCommentDocument = gql`
    mutation VoteComment($input: VoteCommentMutationInput!) {
  voteComment(input: $input) {
    vote {
      count
    }
  }
}
    `
export type VoteCommentMutationFn = Apollo.MutationFunction<VoteCommentMutation, VoteCommentMutationVariables>;

/**
 * __useVoteCommentMutation__
 *
 * To run a mutation, you first call `useVoteCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVoteCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [voteCommentMutation, { data, loading, error }] = useVoteCommentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useVoteCommentMutation(baseOptions?: Apollo.MutationHookOptions<VoteCommentMutation, VoteCommentMutationVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<VoteCommentMutation, VoteCommentMutationVariables>(VoteCommentDocument, options)
}
export type VoteCommentMutationHookResult = ReturnType<typeof useVoteCommentMutation>;
export type VoteCommentMutationResult = Apollo.MutationResult<VoteCommentMutation>;
export type VoteCommentMutationOptions = Apollo.BaseMutationOptions<VoteCommentMutation, VoteCommentMutationVariables>;
export const TopicTopicSectionsDocument = gql`
    query TopicTopicSections($topicId: ID!, $paginate: PaginateInput) {
  topicTopicSections(topicId: $topicId, paginate: $paginate) {
    node {
      codeSuggestions {
        content
        cost
        createdAt
        id
        language {
          canJudge
          createdAt
          id
          name
          reactAceKey
          updatedAt
        }
        languageId
        topicSectionId
        updatedAt
      }
      createdAt
      id
      sectionItem {
        ... on CodingExam {
          description
          difficulty
          id
          limit {
            memoryLimit
            sourceLimit
            timeLimit
          }
          maxPoints
          slug
          tagList
          title
        }
        ... on CourseLesson {
          content
          duration
          difficulty
          featureImage {
            downloadUrl
            filename
            id
            metadata
            thumbnailUrl
          }
          id
          maxPoints
          slug
          tagList
          title
        }
        ... on GapFillExam {
          content
          description
          difficulty
          id
          maxPoints
          slug
          tagList
          title
        }
        ... on OrganizedExam {
          canRunCode
          content
          description
          difficulty
          id
          maxPoints
          slug
          tagList
          title
        }
        ... on QuizExam {
          description
          difficulty
          id
          maxPoints
          slug
          tagList
          title
          quizQuestBridges {
            id
            quizQuest {
              description
              id
              isSingleChoice
              name
              options {
                content
                id
              }
              title
            }
          }
        }
      }
    }
    pageInfo {
      totalPages
      totalCount
      currentPage
    }
  }
}
    `

/**
 * __useTopicTopicSectionsQuery__
 *
 * To run a query within a React component, call `useTopicTopicSectionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTopicTopicSectionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopicTopicSectionsQuery({
 *   variables: {
 *      topicId: // value for 'topicId'
 *      paginate: // value for 'paginate'
 *   },
 * });
 */
export function useTopicTopicSectionsQuery(baseOptions: Apollo.QueryHookOptions<TopicTopicSectionsQuery, TopicTopicSectionsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<TopicTopicSectionsQuery, TopicTopicSectionsQueryVariables>(TopicTopicSectionsDocument, options)
}
export function useTopicTopicSectionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TopicTopicSectionsQuery, TopicTopicSectionsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<TopicTopicSectionsQuery, TopicTopicSectionsQueryVariables>(TopicTopicSectionsDocument, options)
}
export type TopicTopicSectionsQueryHookResult = ReturnType<typeof useTopicTopicSectionsQuery>;
export type TopicTopicSectionsLazyQueryHookResult = ReturnType<typeof useTopicTopicSectionsLazyQuery>;
export type TopicTopicSectionsQueryResult = Apollo.QueryResult<TopicTopicSectionsQuery, TopicTopicSectionsQueryVariables>;
